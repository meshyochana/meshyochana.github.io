<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiling by Near Coincidence Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: #f0f2f5;
        }

        #controls {
            width: 380px; 
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
        }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #e9eef2;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: white;
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .control-group {
            margin-bottom: 15px; 
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 15px; 
        }

        .control-group:last-child {
            border-bottom: none;
        }
         .edge-config-item {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        details {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f9fafb;
        }
        details > summary {
            font-weight: bold;
            cursor: pointer;
            color: #333;
            padding: 5px;
            list-style: none; /* Remove default marker */
        }
        details > summary::-webkit-details-marker {
            display: none; /* Chrome/Safari */
        }
        details > summary::before {
            content: '▶'; /* Collapsed state */
            margin-right: 8px;
            font-size: 0.8em;
            display: inline-block;
            transition: transform 0.2s;
        }
        details[open] > summary::before {
            transform: rotate(90deg); /* Expanded state */
        }

        h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
        }

        h4, details > summary {
            margin-top: 0;
            margin-bottom: 5px;
            color: #555;
            font-size: 1.1em;
        }
         h4 .layer-color-indicator, .summary-color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #777;
            border-radius: 3px;
            vertical-align: middle;
        }


        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #666;
            font-weight: 500;
        }
        .label-with-icon {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .shape-icon svg {
            width: 20px;
            height: 20px;
            fill: #555;
        }

        .label-inline {
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }

        input[type="number"],
        select,
        button,
        input[type="color"] { 
            width: 100%;
            padding: 8px; 
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #fff;
        }
        input[type="color"] {
             width: 100%; 
             padding: 5px;
             height: 35px; 
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
            border: none;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.add-button {
            background-color: #28a745; /* Green */
            margin-top: 5px;
        }
        button.add-button:hover {
            background-color: #218838;
        }
        button.remove-button {
            background-color: #dc3545; /* Red */
            font-size: 0.8em;
            padding: 5px 8px;
            width: auto; /* Fit content */
            margin-top: 5px;
            float: right; /* Align remove button to the right */
        }
        button.remove-button:hover {
            background-color: #c82333;
        }
        button.secondary-button { /* New for restore button */
            background-color: #6c757d;
        }
        button.secondary-button:hover {
            background-color: #5a6268;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input-group input[type="range"] {
            flex-grow: 1;
            padding: 0;
            margin-bottom: 0; 
        }

        .input-group input[type="number"] {
            width: 70px; 
            margin-bottom: 0; 
        }


        input[type="range"] {
            width: 100%; 
            padding: 0;
             margin-bottom: 10px;
        }
        input[type="checkbox"]{
            vertical-align: middle;
            width: auto;
            margin-right: 5px;
        }
        .orientation-canvas {
            border: 1px solid #ccc;
            margin: 5px;
            display: inline-block;
            vertical-align: middle;
            border-radius: 4px;
        }
        .shape-control-container {
            border-top: 1px solid #eee;
            margin-top: 15px;
            padding-top: 15px;
        }

        /* Styles for Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
         .modal-content h2 { margin-top: 0; }
         .modal-content p, .modal-content li { line-height: 1.6; }
         .modal-content ul { padding-left: 20px; }
         .modal-content button { width: auto; padding: 8px 16px; float: right; margin-top: 15px; }

    </style>
</head>
<body>
    <div id="controls">
        <button id="infoButton" class="secondary-button" style="width: 100%; margin-bottom: 15px;">How to use this app?</button>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
            <button id="exportSettingsButton">Export Settings</button>
            <button id="importSettingsButton">Import Settings</button>
        </div>
        <div class="control-group">
            <h3>Global Settings</h3>
            <label for="latticeSize">Lattice Area Size (L x L pixels):</label>
            <input type="number" id="latticeSize" value="500" min="100" max="800">
            
            <label for="baseSpacing">Base Lattice Spacing (px):</label>
            <input type="number" id="baseSpacing" value="40" min="10" max="100">

            <label for="numLayers">Number of Layers:</label>
            <select id="numLayers">
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
            </select>

            <label for="pointSize">Base Layer Point Size (radius, px):</label>
            <input type="number" id="pointSize" value="3" min="0.5" max="10" step="0.5">
            
            <label for="interactionPointSize">Interaction Point Size (radius, px):</label>
            <input type="number" id="interactionPointSize" value="4" min="0.5" max="10" step="0.5">

            <label id="colormapGammaLabel" for="colormapGamma" style="margin-top:11px;">Colormap Sensitivity (γ): 1.00</label>
            <div class="input-group">
                <input type="range" id="colormapGamma" value="1" min="0.1" max="5" step="0.01">
                <input type="number" id="colormapGammaNumber" value="1" min="0.1" max="5" step="0.01">
            </div>
            <canvas id="colormapCanvas" width="340" height="50" style="border: 1px solid #ddd; border-radius: 4px; margin-top: -5px;"></canvas>

        </div>
        
        <div class="control-group">
            <h3>Interaction Layer Settings</h3>
            <div>
                <input type="checkbox" id="enableInteractions" checked>
                <label for="enableInteractions" class="label-inline">Enable Interaction Layer</label>
            </div>
            <label id="distanceThresholdLabel" for="distanceThresholdNumber" style="margin-top:11px;">Interaction Radius: 0.50</label>
             <div class="input-group">
                <input type="range" id="distanceThreshold" value="0.5" min="0.01" max="1" step="0.001">
                <input type="number" id="distanceThresholdNumber" value="0.5" min="0.01" max="1" step="0.001">
            </div>

            <details>
                <summary>Advanced Settings</summary>
                <div style="padding-top: 10px;">
                    <div class="label-with-icon">
                        <label for="interactionShape1">Interaction Shape 1:</label>
                    </div>
                    <select id="interactionShape1">
                        </select>
                    <label id="interactionAngleLabel1" for="interactionAngle1">Shape 1 Rotation: 0.0°</label>
                    <div class="input-group">
                        <input type="range" id="interactionAngle1" value="0" min="0" max="360" step="0.1">
                        <input type="number" id="interactionAngleNumber1" value="0" min="0" max="360" step="0.1">
                    </div>
                    <label id="interactionShiftXLabel1" for="interactionShiftX1">Shape 1 Shift X: 0.000</label>
                    <div class="input-group">
                        <input type="range" id="interactionShiftX1" value="0" min="-1" max="1" step="0.001">
                        <input type="number" id="interactionShiftXNumber1" value="0" min="-1" max="1" step="0.001">
                    </div>
                    <label id="interactionShiftYLabel1" for="interactionShiftY1">Shape 1 Shift Y: 0.000</label>
                    <div class="input-group">
                        <input type="range" id="interactionShiftY1" value="0" min="-1" max="1" step="0.001">
                        <input type="number" id="interactionShiftYNumber1" value="0" min="-1" max="1" step="0.001">
                    </div>

                    <div class="shape-control-container">
                        <div>
                             <input type="checkbox" id="enableShape2">
                             <label for="enableShape2" class="label-inline">Enable Second Shape</label>
                        </div>
                        <div id="shape2-controls" style="display: none;">
                             <label for="interactionShape2" style="margin-top:10px;">Interaction Shape 2:</label>
                             <select id="interactionShape2">
                                 </select>
                             <label id="interactionAngleLabel2" for="interactionAngle2">Shape 2 Rotation: 0.0°</label>
                             <div class="input-group">
                                 <input type="range" id="interactionAngle2" value="0" min="0" max="360" step="0.1">
                                 <input type="number" id="interactionAngleNumber2" value="0" min="0" max="360" step="0.1">
                             </div>
                            <label id="interactionShiftXLabel2" for="interactionShiftX2">Shape 2 Shift X: 0.000</label>
                            <div class="input-group">
                                <input type="range" id="interactionShiftX2" value="0" min="-1" max="1" step="0.001">
                                <input type="number" id="interactionShiftXNumber2" value="0" min="-1" max="1" step="0.001">
                            </div>
                            <label id="interactionShiftYLabel2" for="interactionShiftY2">Shape 2 Shift Y: 0.000</label>
                            <div class="input-group">
                                <input type="range" id="interactionShiftY2" value="0" min="-1" max="1" step="0.001">
                                <input type="number" id="interactionShiftYNumber2" value="0" min="-1" max="1" step="0.001">
                            </div>
                        </div>
                    </div>
                     <div style="text-align: center; margin-top: 10px;">
                        <label>Shape Orientations</label>
                        <div>
                            <canvas id="orientationCanvas1" width="80" height="80" class="orientation-canvas"></canvas>
                            <canvas id="orientationCanvas2" width="80" height="80" class="orientation-canvas" style="display: none;"></canvas>
                        </div>
                    </div>

                    <div style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px;">
                        <label for="edgeMethod">Edge Calculation Method:</label>
                        <select id="edgeMethod">
                            <option value="naive" selected>Distance-based (Naive)</option>
                            <option value="delaunay">Delaunay Triangulation</option>
                        </select>
                    </div>
                </div>
            </details>

            <details id="edge-config-panel">
                <summary>Edge Filters</summary>
                <div id="interaction-edge-configs-container" style="padding-top:10px;"></div>
                <button id="add-edge-config-button" class="add-button">+ Add Edge Filter</button>
                <button id="restoreEdgesButton" class="secondary-button" style="margin-top: 10px; width: 100%;">Restore Removed Edges</button>
            </details>
            
            <button id="exportInteractionPointsButton" style="margin-top: 15px;">Export Interaction Points (TXT)</button>
        </div>


        <div id="layers-controls-container">
            </div>
    </div>

    <div id="canvas-container">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        const controls = {
            latticeSize: document.getElementById('latticeSize'),
            baseSpacing: document.getElementById('baseSpacing'),
            numLayers: document.getElementById('numLayers'),
            pointSize: document.getElementById('pointSize'),
            interactionPointSize: document.getElementById('interactionPointSize'),
            colormapGamma: document.getElementById('colormapGamma'),
            colormapGammaNumber: document.getElementById('colormapGammaNumber'),
            colormapGammaLabel: document.getElementById('colormapGammaLabel'),
            colormapCanvas: document.getElementById('colormapCanvas'),
            layersControlsContainer: document.getElementById('layers-controls-container'),
            distanceThreshold: document.getElementById('distanceThreshold'),
            distanceThresholdNumber: document.getElementById('distanceThresholdNumber'),
            distanceThresholdLabel: document.getElementById('distanceThresholdLabel'),
            enableInteractions: document.getElementById('enableInteractions'),
            exportInteractionPointsButton: document.getElementById('exportInteractionPointsButton'),
            interactionEdgeConfigsContainer: document.getElementById('interaction-edge-configs-container'),
            addEdgeConfigButton: document.getElementById('add-edge-config-button'),
            // Advanced controls
            interactionShape1: document.getElementById('interactionShape1'),
            interactionAngle1: document.getElementById('interactionAngle1'),
            interactionAngleNumber1: document.getElementById('interactionAngleNumber1'),
            interactionAngleLabel1: document.getElementById('interactionAngleLabel1'),
            interactionShiftX1: document.getElementById('interactionShiftX1'),
            interactionShiftXNumber1: document.getElementById('interactionShiftXNumber1'),
            interactionShiftXLabel1: document.getElementById('interactionShiftXLabel1'),
            interactionShiftY1: document.getElementById('interactionShiftY1'),
            interactionShiftYNumber1: document.getElementById('interactionShiftYNumber1'),
            interactionShiftYLabel1: document.getElementById('interactionShiftYLabel1'),

            // Shape 2 controls
            enableShape2: document.getElementById('enableShape2'),
            shape2Controls: document.getElementById('shape2-controls'),
            interactionShape2: document.getElementById('interactionShape2'),
            interactionAngle2: document.getElementById('interactionAngle2'),
            interactionAngleNumber2: document.getElementById('interactionAngleNumber2'),
            interactionAngleLabel2: document.getElementById('interactionAngleLabel2'),
            interactionShiftX2: document.getElementById('interactionShiftX2'),
            interactionShiftXNumber2: document.getElementById('interactionShiftXNumber2'),
            interactionShiftXLabel2: document.getElementById('interactionShiftXLabel2'),
            interactionShiftY2: document.getElementById('interactionShiftY2'),
            interactionShiftYNumber2: document.getElementById('interactionShiftYNumber2'),
            interactionShiftYLabel2: document.getElementById('interactionShiftYLabel2'),
            
            edgeMethod: document.getElementById('edgeMethod'),
            edgeConfigPanel: document.getElementById('edge-config-panel'),
            exportSettingsButton: document.getElementById('exportSettingsButton'),
            importSettingsButton: document.getElementById('importSettingsButton'),
            infoButton: document.getElementById('infoButton')
        };

        const layerColors = ['red', 'blue', 'green', 'orange', 'purple', 'magenta', 'yellow', 'pink', 'brown'];
        let layers = [];
        let lastRenderedInteractionPoints = []; 
        let edgeConfigs = [];
        let edgeConfigCounter = 0; 
        let removedEdges = new Set();
        let allDrawableEdges = []; // Used for click detection on edges

        // --- Viridis Colormap ---
        const viridisColormap = [
            { t: 0.0,  rgb: [68,  1,   84] },  { t: 0.1,  rgb: [72,  40,  120] }, 
            { t: 0.2,  rgb: [62,  74,  137] }, { t: 0.3,  rgb: [49,  104, 142] },
            { t: 0.4,  rgb: [38,  130, 142] }, { t: 0.5,  rgb: [31,  158, 137] },
            { t: 0.6,  rgb: [53,  183, 121] }, { t: 0.7,  rgb: [109, 205,  89] },
            { t: 0.8,  rgb: [180, 222,  44] }, { t: 0.9,  rgb: [248, 231,  28] },
            { t: 1.0,  rgb: [253, 231,  37] }
        ];

        function getViridisColor(t) {
            t = Math.max(0, Math.min(1, t)); 
            for (let i = 0; i < viridisColormap.length - 1; i++) {
                const c1 = viridisColormap[i]; const c2 = viridisColormap[i+1];
                if (t >= c1.t && t <= c2.t) {
                    const local_t = (t - c1.t) / (c2.t - c1.t);
                    const r = Math.round(c1.rgb[0] * (1 - local_t) + c2.rgb[0] * local_t);
                    const g = Math.round(c1.rgb[1] * (1 - local_t) + c2.rgb[1] * local_t);
                    const b = Math.round(c1.rgb[2] * (1 - local_t) + c2.rgb[2] * local_t);
                    return `rgb(${r},${g},${b})`;
                }
            }
            const lastColor = viridisColormap[viridisColormap.length - 1].rgb;
            return `rgb(${lastColor[0]},${lastColor[1]},${lastColor[2]})`;
        }

        // --- Point Generation Functions ---
        function generateSquareLatticePoints(size, spacing) {
            const points = []; if (spacing <= 0) return points;
            const numStepsHalf = Math.ceil(size / (2 * spacing));
            for (let i = -numStepsHalf; i <= numStepsHalf; i++) {
                const x = i * spacing;
                for (let j = -numStepsHalf; j <= numStepsHalf; j++) {
                    const y = j * spacing; points.push({ x, y });
                }
            }
            return points;
        }

        function generateTriangularLatticePoints(size, spacing) {
            const points = []; if (spacing <= 0) return points;
            const h = spacing * Math.sqrt(3) / 2; if (h <= 0) return points; 
            const numYRowsHalf = Math.ceil(size / (2 * h));
            const numXPointsHalf = Math.ceil(size / (2 * spacing));
            for (let j = -numYRowsHalf; j <= numYRowsHalf; j++) {
                const y = j * h; const isOffsetRow = (Math.abs(j) % 2 === 1); 
                for (let k = -numXPointsHalf; k <= numXPointsHalf; k++) {
                    let x = k * spacing; if (isOffsetRow) { x += spacing / 2; }
                    points.push({ x, y });
                }
            }
            return points;
        }

        function generateHoneycombPointLatticePoints(size, sideLength) {
            const rawPoints = []; 
            if (sideLength <= 0) return rawPoints;
            const hexWidth = Math.sqrt(3) * sideLength; 
            const hexHeight = 2 * sideLength;      
            const vertSpacing = hexHeight * 3/4; 
            const horizSpacing = hexWidth;       
            const numRowsForLoop = Math.ceil((size / vertSpacing) / 2) + 2; 
            const numColsForLoop = Math.ceil((size / horizSpacing) / 2) + 2; 
            const uniqueVertices = new Set(); 
            for (let r = -numRowsForLoop; r <= numRowsForLoop; r++) {
                for (let c = -numColsForLoop; c <= numColsForLoop; c++) {
                    const xCenter = c * horizSpacing + (Math.abs(r) % 2 === 1 ? horizSpacing / 2 : 0); 
                    const yCenter = r * vertSpacing;
                    for (let i = 0; i < 6; i++) {
                        const angle_rad = (Math.PI / 3) * i + Math.PI / 6; 
                        const vx = xCenter + sideLength * Math.cos(angle_rad); 
                        const vy = yCenter + sideLength * Math.sin(angle_rad);
                        const key = `${vx.toFixed(3)},${vy.toFixed(3)}`; 
                        if (!uniqueVertices.has(key)) { 
                            rawPoints.push({ x: vx, y: vy }); 
                            uniqueVertices.add(key);
                        }
                    }
                }
            }
            if (rawPoints.length === 0) return [];
            let closestPoint = rawPoints[0];
            let minDistanceSq = closestPoint.x * closestPoint.x + closestPoint.y * closestPoint.y;
            for (let i = 1; i < rawPoints.length; i++) {
                const p = rawPoints[i];
                const distSq = p.x * p.x + p.y * p.y;
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestPoint = p;
                }
            }
            const shiftX = -closestPoint.x; const shiftY = -closestPoint.y;
            return rawPoints.map(p => ({ x: p.x + shiftX, y: p.y + shiftY }));
        }

        // --- Transformation and Utility Functions ---
        function transformPoint(point, L, layerConfig, baseSpacing) {
            let { x, y } = point; 
            x *= layerConfig.scale; y *= layerConfig.scale;
            const angleRad = layerConfig.angle * Math.PI / 180;
            const cosA = Math.cos(angleRad); const sinA = Math.sin(angleRad);
            const rotatedX = x * cosA - y * sinA; const rotatedY = x * sinA + y * cosA;
            // Shifts are in units, convert to pixels
            const shiftX_px = layerConfig.shiftX * baseSpacing;
            const shiftY_px = layerConfig.shiftY * baseSpacing;
            return { x: L / 2 + rotatedX + shiftX_px, y: L / 2 + rotatedY + shiftY_px };
        }
        
        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function getColorForDistance(distance, threshold_px, gamma) {
            const epsilon = 0.001; 
            const val = -distance; 
            const val_max = -epsilon; 
            const val_min = -threshold_px; 
            let normalized_val = (val_max === val_min) ? 0.5 : (val - val_min) / (val_max - val_min);
            normalized_val = 1 - Math.max(0, Math.min(1, normalized_val)); 
            const gamma_corrected_val = Math.pow(normalized_val, gamma);
            return getViridisColor(gamma_corrected_val);
        }

        function isPointInPolygon(point, vs) {
            const x = point.x, y = point.y;
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i].x, yi = vs[i].y;
                const xj = vs[j].x, yj = vs[j].y;
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getDistanceToSegment(clickPoint, p1, p2) {
            const l2 = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            if (l2 === 0) return calculateDistance(clickPoint, p1);
            let t = ((clickPoint.x - p1.x) * (p2.x - p1.x) + (clickPoint.y - p1.y) * (p2.y - p1.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const closestPointOnSegment = {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
            };
            return calculateDistance(clickPoint, closestPointOnSegment);
        }


        // --- Layer Control Generation ---
        function getDefaultLayer(index, type = 'square') {
             return {
                id: `layer-${index + 1}`, type,
                color: layerColors[index % layerColors.length],
                angle: 0, scale: 1.0, 
                shiftX: 0, // in units
                shiftY: 0, // in units
                visible: true,
                contributesToInteraction: true,
                alpha: 0.3, 
                localPointsCache: null, transformedPointsCache: null 
            };
        }

        function updateNumberOfLayers() {
            const num = parseInt(controls.numLayers.value);
            const currentGlobalType = layers.length > 0 && layers[0].type ? layers[0].type : 'square'; 
            const newLayers = [];
            for (let i = 0; i < num; i++) {
                if (layers[i]) { 
                    newLayers.push(layers[i]);
                } else { 
                    newLayers.push(getDefaultLayer(i, currentGlobalType));
                }
            }
            layers = newLayers.slice(0, num); 
            generateLayerControls(); 
            invalidateAllPointCaches(); 
            drawSimulation(); 
        }
        
        function invalidateAllPointCaches() {
            layers.forEach(l => { l.localPointsCache = null; l.transformedPointsCache = null;});
        }

        function invalidateLayerPointCache(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) { layer.localPointsCache = null; layer.transformedPointsCache = null;}
        }

        function generateLayerControls() {
            controls.layersControlsContainer.innerHTML = ''; 
            const L = parseInt(controls.latticeSize.value);
            const baseSpacing = parseFloat(controls.baseSpacing.value);
            const maxShiftUnits = baseSpacing > 0 ? (L / 2) / baseSpacing : 0;

            layers.forEach((layer, index) => {
                const layerDetails = document.createElement('details');
                layerDetails.className = 'layer-controls';
                layerDetails.id = `controls-${layer.id}`;
                
                const layerSummary = document.createElement('summary');
                const colorIndicator = `<span class="summary-color-indicator" style="background-color: ${layer.color};"></span>`;
                layerSummary.innerHTML = `${colorIndicator}Layer ${index + 1}`;
                layerDetails.appendChild(layerSummary);

                const layerDiv = document.createElement('div');
                layerDiv.style.paddingTop = '10px';
                
                const typeLabel = document.createElement('label'); typeLabel.textContent = 'Layer Type:';
                const typeSelect = document.createElement('select'); typeSelect.id = `type-${layer.id}`;
                ['square', 'triangular', 'honeycomb'].forEach(type => {
                    const option = document.createElement('option'); option.value = type; option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    if (type === layer.type) option.selected = true; typeSelect.appendChild(option);
                });
                typeSelect.addEventListener('change', (e) => { layer.type = e.target.value; invalidateLayerPointCache(layer.id); drawSimulation(); });
                layerDiv.appendChild(typeLabel); layerDiv.appendChild(typeSelect);

                // Angle
                const angleGroup = document.createElement('div'); angleGroup.className = 'input-group';
                const angleLabel = document.createElement('label'); angleLabel.textContent = `Angle: ${layer.angle.toFixed(2)}°`;
                const angleInput = document.createElement('input'); angleInput.type = 'range'; angleInput.min = 0; angleInput.max = 180; angleInput.value = layer.angle; angleInput.step = 0.01;
                const angleNumberInput = document.createElement('input'); angleNumberInput.type = 'number'; angleNumberInput.min = 0; angleNumberInput.max = 180; angleNumberInput.value = layer.angle.toFixed(2); angleNumberInput.step = 0.01;
                
                const angleUpdate = (val) => {
                    layer.angle = val;
                    angleLabel.textContent = `Angle: ${val.toFixed(2)}°`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                angleInput.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    angleNumberInput.value = v.toFixed(2);
                    angleUpdate(v);
                });
                angleNumberInput.addEventListener('input', e => {
                    const v = parseFloat(e.target.value);
                    if(!isNaN(v)) {
                        angleInput.value = v;
                        layer.angle = v;
                        angleLabel.textContent = `Angle: ${v}°`;
                        invalidateLayerPointCache(layer.id);
                        drawSimulation();
                    }
                });
                angleNumberInput.addEventListener('change', e => {
                    let v = parseFloat(e.target.value);
                    const min = parseFloat(angleInput.min);
                    const max = parseFloat(angleInput.max);
                    if(isNaN(v)) v = 0;
                    const cV = Math.max(min, Math.min(max, v));
                    e.target.value = cV.toFixed(2);
                    angleInput.value = cV;
                    angleUpdate(cV);
                });
                layerDiv.appendChild(angleLabel); angleGroup.appendChild(angleInput); angleGroup.appendChild(angleNumberInput); layerDiv.appendChild(angleGroup);

                // Scale
                const scaleGroup = document.createElement('div'); scaleGroup.className = 'input-group';
                const scaleLabel = document.createElement('label'); scaleLabel.textContent = `Scale: ${layer.scale.toFixed(3)}`;
                const scaleInput = document.createElement('input'); scaleInput.type = 'range'; scaleInput.min = 0.1; scaleInput.max = 3; scaleInput.value = layer.scale; scaleInput.step = 0.001;
                const scaleNumberInput = document.createElement('input'); scaleNumberInput.type = 'number'; scaleNumberInput.min = 0.1; scaleNumberInput.max = 3; scaleNumberInput.value = layer.scale.toFixed(3); scaleNumberInput.step = 0.001;
                
                const scaleUpdate = (val) => {
                    layer.scale = val;
                    scaleLabel.textContent = `Scale: ${val.toFixed(3)}`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                scaleInput.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    scaleNumberInput.value = v.toFixed(3);
                    scaleUpdate(v);
                });
                scaleNumberInput.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    if(!isNaN(v)) {
                        scaleInput.value = v;
                        layer.scale = v;
                        scaleLabel.textContent = `Scale: ${v}`;
                        invalidateLayerPointCache(layer.id);
                        drawSimulation();
                    }
                });
                scaleNumberInput.addEventListener('change', (e) => {
                    let v = parseFloat(e.target.value);
                    const min = parseFloat(scaleInput.min);
                    const max = parseFloat(scaleInput.max);
                    if(isNaN(v)) v = min;
                    const cV = Math.max(min, Math.min(max, v));
                    e.target.value = cV.toFixed(3);
                    scaleInput.value = cV;
                    scaleUpdate(cV);
                });
                layerDiv.appendChild(scaleLabel); scaleGroup.appendChild(scaleInput); scaleGroup.appendChild(scaleNumberInput); layerDiv.appendChild(scaleGroup);
                
                // Shift X (units)
                const shiftXGroup = document.createElement('div'); shiftXGroup.className = 'input-group';
                const shiftXLabel = document.createElement('label'); shiftXLabel.textContent = `Shift X: ${layer.shiftX.toFixed(3)}`;
                const shiftXRange = document.createElement('input'); shiftXRange.type = 'range'; shiftXRange.min = 0; shiftXRange.max = maxShiftUnits.toFixed(3); shiftXRange.value = layer.shiftX; shiftXRange.step = 0.001;
                const shiftXNumber = document.createElement('input'); shiftXNumber.type = 'number'; shiftXNumber.min = 0; shiftXNumber.max = maxShiftUnits.toFixed(3); shiftXNumber.value = layer.shiftX.toFixed(3); shiftXNumber.step = 0.001;
                
                const shiftXUpdate = (val) => {
                    layer.shiftX = val;
                    shiftXLabel.textContent = `Shift X: ${val.toFixed(3)}`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                shiftXRange.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    shiftXNumber.value = v.toFixed(3);
                    shiftXUpdate(v);
                });
                shiftXNumber.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    if(!isNaN(v)) {
                        shiftXRange.value = v;
                        layer.shiftX = v;
                        shiftXLabel.textContent = `Shift X: ${v}`;
                        invalidateLayerPointCache(layer.id);
                        drawSimulation();
                    }
                });
                shiftXNumber.addEventListener('change', (e) => {
                    let v = parseFloat(e.target.value);
                    const min = parseFloat(shiftXRange.min);
                    const max = parseFloat(shiftXRange.max);
                    if (isNaN(v)) v = min;
                    const cV = Math.max(min, Math.min(max, v));
                    e.target.value = cV.toFixed(3);
                    shiftXRange.value = cV;
                    shiftXUpdate(cV);
                });
                layerDiv.appendChild(shiftXLabel); shiftXGroup.appendChild(shiftXRange); shiftXGroup.appendChild(shiftXNumber); layerDiv.appendChild(shiftXGroup);
                
                // Shift Y (units)
                const shiftYGroup = document.createElement('div'); shiftYGroup.className = 'input-group';
                const shiftYLabel = document.createElement('label'); shiftYLabel.textContent = `Shift Y: ${layer.shiftY.toFixed(3)}`;
                const shiftYRange = document.createElement('input'); shiftYRange.type = 'range'; shiftYRange.min = 0; shiftYRange.max = maxShiftUnits.toFixed(3); shiftYRange.value = layer.shiftY; shiftYRange.step = 0.001;
                const shiftYNumber = document.createElement('input'); shiftYNumber.type = 'number'; shiftYNumber.min = 0; shiftYNumber.max = maxShiftUnits.toFixed(3); shiftYNumber.value = layer.shiftY.toFixed(3); shiftYNumber.step = 0.001;
                
                const shiftYUpdate = (val) => {
                    layer.shiftY = val;
                    shiftYLabel.textContent = `Shift Y: ${val.toFixed(3)}`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                shiftYRange.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    shiftYNumber.value = v.toFixed(3);
                    shiftYUpdate(v);
                });
                shiftYNumber.addEventListener('input', (e) => {
                     const v = parseFloat(e.target.value);
                    if(!isNaN(v)) {
                        shiftYRange.value = v;
                        layer.shiftY = v;
                        shiftYLabel.textContent = `Shift Y: ${v}`;
                        invalidateLayerPointCache(layer.id);
                        drawSimulation();
                    }
                });
                shiftYNumber.addEventListener('change', (e) => {
                    let v = parseFloat(e.target.value);
                    const min = parseFloat(shiftYRange.min);
                    const max = parseFloat(shiftYRange.max);
                    if (isNaN(v)) v = min;
                    const cV = Math.max(min, Math.min(max, v));
                    e.target.value = cV.toFixed(3);
                    shiftYRange.value = cV;
                    shiftYUpdate(cV);
                });
                layerDiv.appendChild(shiftYLabel); shiftYGroup.appendChild(shiftYRange); shiftYGroup.appendChild(shiftYNumber); layerDiv.appendChild(shiftYGroup);

                // Alpha
                const alphaGroup = document.createElement('div'); alphaGroup.className = 'input-group';
                const alphaLabel = document.createElement('label'); alphaLabel.textContent = `Alpha: ${layer.alpha.toFixed(2)}`;
                const alphaInput = document.createElement('input'); alphaInput.type = 'range'; alphaInput.min = 0; alphaInput.max = 1; alphaInput.value = layer.alpha; alphaInput.step = 0.01;
                const alphaNumberInput = document.createElement('input'); alphaNumberInput.type = 'number'; alphaNumberInput.min = 0; alphaNumberInput.max = 1; alphaNumberInput.value = layer.alpha.toFixed(2); alphaNumberInput.step = 0.01;
                
                const alphaUpdate = (val) => {
                    layer.alpha = val;
                    alphaLabel.textContent = `Alpha: ${val.toFixed(2)}`;
                    drawSimulation();
                };
                alphaInput.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    alphaNumberInput.value = v.toFixed(2);
                    alphaUpdate(v);
                });
                alphaNumberInput.addEventListener('input', (e) => {
                    const v = parseFloat(e.target.value);
                    if(!isNaN(v)) {
                        alphaInput.value = v;
                        layer.alpha = v;
                        alphaLabel.textContent = `Alpha: ${v}`;
                        drawSimulation();
                    }
                });
                alphaNumberInput.addEventListener('change', (e) => {
                    let v = parseFloat(e.target.value);
                    const min = parseFloat(alphaInput.min);
                    const max = parseFloat(alphaInput.max);
                    if(isNaN(v)) v = min;
                    const cV = Math.max(min, Math.min(max, v));
                    e.target.value = cV.toFixed(2);
                    alphaInput.value = cV;
                    alphaUpdate(cV);
                });
                layerDiv.appendChild(alphaLabel); alphaGroup.appendChild(alphaInput); alphaGroup.appendChild(alphaNumberInput); layerDiv.appendChild(alphaGroup);
                
                // Visibility and Interaction Checkboxes
                const visibleLabel = document.createElement('label');
                const visibleCheckbox = document.createElement('input');
                visibleCheckbox.type = 'checkbox';
                visibleCheckbox.checked = layer.visible;
                visibleCheckbox.addEventListener('change', (e) => { 
                    layer.visible = e.target.checked;
                    drawSimulation(); 
                }); 
                visibleLabel.appendChild(visibleCheckbox);
                visibleLabel.append(` Visible`);
                layerDiv.appendChild(visibleLabel);

                const interactionLabel = document.createElement('label');
                const interactionCheckbox = document.createElement('input');
                interactionCheckbox.type = 'checkbox';
                interactionCheckbox.checked = layer.contributesToInteraction;
                interactionCheckbox.addEventListener('change', (e) => {
                    layer.contributesToInteraction = e.target.checked;
                    drawSimulation();
                });
                interactionLabel.appendChild(interactionCheckbox);
                interactionLabel.append(' Contributes to Interaction');
                layerDiv.appendChild(interactionLabel);
                
                layerDetails.appendChild(layerDiv);
                controls.layersControlsContainer.appendChild(layerDetails);
            });
        }
        
        // --- Main Drawing Logic ---
        function drawSimulation() {
            const L = parseInt(controls.latticeSize.value);
            const baseSpacing = parseFloat(controls.baseSpacing.value);
            if(isNaN(L) || isNaN(baseSpacing) || baseSpacing <= 0) return;

            canvas.width = L; 
            canvas.height = L;
            const mainPointSize = parseFloat(controls.pointSize.value);
            
            let minEffectiveScale = 1;
            const contributingLayers = layers.filter(l => l.contributesToInteraction);
            if (contributingLayers.length > 0) {
                 minEffectiveScale = Math.min(...contributingLayers.map(l => l.scale));
            }
            const drawL = L * 1.8 / Math.max(0.1, minEffectiveScale); 

            ctx.clearRect(0, 0, L, L); 
            let currentFramePrecomputedData = []; 

            layers.forEach(layerConfig => {
                let localPts = layerConfig.localPointsCache;
                let transformedPts = layerConfig.transformedPointsCache;
                if (!localPts) { 
                    switch (layerConfig.type) {
                        case 'square': localPts = generateSquareLatticePoints(drawL, baseSpacing); break;
                        case 'triangular': localPts = generateTriangularLatticePoints(drawL, baseSpacing); break;
                        case 'honeycomb': localPts = generateHoneycombPointLatticePoints(drawL, baseSpacing / Math.sqrt(3) * 2 / 2 ); break; 
                        default: localPts = [];
                    }
                    layerConfig.localPointsCache = localPts;
                    layerConfig.transformedPointsCache = null; 
                }
                
                if (!layerConfig.transformedPointsCache) { 
                     transformedPts = localPts.map(p => transformPoint(p, L, layerConfig, baseSpacing));
                     layerConfig.transformedPointsCache = transformedPts;
                } else {
                    transformedPts = layerConfig.transformedPointsCache;
                }

                currentFramePrecomputedData.push({ ...layerConfig, transformedPoints: transformedPts });
                
                if (layerConfig.visible) {
                    ctx.globalAlpha = layerConfig.alpha; 
                    ctx.fillStyle = layerConfig.color;
                    transformedPts.forEach(p => {
                        if (p.x >= -mainPointSize && p.x <= L + mainPointSize && p.y >= -mainPointSize && p.y <= L + mainPointSize) {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, mainPointSize, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    });
                }
            });

            ctx.globalAlpha = 1.0; 
            if (layers.length > 1) { 
                drawInteractionLayer(L, currentFramePrecomputedData, baseSpacing);
            } else {
                lastRenderedInteractionPoints = []; 
            }
        }

        // --- Edge Configuration Management ---
        function createEdgeConfigHTML(config) {
            const div = document.createElement('div');
            div.className = 'edge-config-item';
            div.id = config.id;

            const headerDiv = document.createElement('div');
            headerDiv.style.overflow = "hidden"; 

            const enableCheckbox = document.createElement('input');
            enableCheckbox.type = 'checkbox';
            enableCheckbox.id = `enable-${config.id}`;
            enableCheckbox.checked = config.enabled;
            
            const enableLabel = document.createElement('label');
            enableLabel.htmlFor = `enable-${config.id}`;
            enableLabel.className = 'label-inline';
            enableLabel.textContent = 'Enable edges';
            enableLabel.style.marginRight = '10px';

            const removeButton = document.createElement('button');
            removeButton.className = 'remove-button';
            removeButton.dataset.id = config.id;
            removeButton.textContent = 'Remove';
            
            headerDiv.appendChild(enableCheckbox);
            headerDiv.appendChild(enableLabel);
            headerDiv.appendChild(removeButton);
            div.appendChild(headerDiv);

            div.innerHTML += `
                <label for="lower-range-${config.id}" style="margin-top:5px;">Min Length:</label>
                <div class="input-group">
                    <input type="range" id="lower-range-${config.id}" value="${config.lowerBound}" min="0" max="20" step="0.01">
                    <input type="number" id="lower-num-${config.id}" value="${config.lowerBound}" min="0" max="20" step="0.01">
                </div>
                <label for="upper-range-${config.id}" style="margin-top:5px;">Max Length:</label>
                <div class="input-group">
                    <input type="range" id="upper-range-${config.id}" value="${config.upperBound}" min="0" max="20" step="0.01">
                    <input type="number" id="upper-num-${config.id}" value="${config.upperBound}" min="0" max="20" step="0.01">
                </div>
                <label for="color-${config.id}">Edge Color:</label>
                <input type="color" id="color-${config.id}" value="${config.color}">
                <label for="width-${config.id}">Edge Width (px):</label>
                <input type="number" id="width-${config.id}" value="${config.width}" min="0.1" max="20" step="0.1" style="width: 70px; margin-bottom: 5px;">
            `;

             div.querySelector(`#enable-${config.id}`).addEventListener('change', (e) => {
                config.enabled = e.target.checked;
                drawSimulation();
            });
             div.querySelector('.remove-button').addEventListener('click', (e) => {
                removeEdgeConfig(e.target.dataset.id);
            });

            const lowerRange = div.querySelector(`#lower-range-${config.id}`);
            const lowerNum = div.querySelector(`#lower-num-${config.id}`);
            const upperRange = div.querySelector(`#upper-range-${config.id}`);
            const upperNum = div.querySelector(`#upper-num-${config.id}`);
            
            // --- Lower Bound Controls ---
            lowerRange.addEventListener('input', () => {
                let val = parseFloat(lowerRange.value);
                config.lowerBound = val;
                
                if (config.upperBound < val) {
                    config.upperBound = val;
                    upperRange.value = val;
                    upperNum.value = val.toFixed(2);
                }
                
                lowerNum.value = val.toFixed(2);
                drawSimulation();
            });

            lowerNum.addEventListener('input', () => {
                const val = parseFloat(lowerNum.value);
                if (!isNaN(val)) {
                    config.lowerBound = val;
                    lowerRange.value = val;
                    
                    if (config.upperBound < val) {
                        config.upperBound = val;
                        upperRange.value = val;
                        upperNum.value = val.toFixed(2);
                    }
                    drawSimulation();
                }
            });

            lowerNum.addEventListener('change', () => {
                let val = parseFloat(lowerNum.value);
                const min = parseFloat(lowerRange.min);
                const max = parseFloat(lowerRange.max);

                if (isNaN(val)) val = min;
                val = Math.max(min, Math.min(max, val));
                config.lowerBound = val;

                if (config.upperBound < val) {
                    config.upperBound = val;
                    upperRange.value = val;
                    upperNum.value = val.toFixed(2);
                }
                
                lowerRange.value = val;
                lowerNum.value = val.toFixed(2);
                drawSimulation();
            });

            // --- Upper Bound Controls ---
            upperRange.addEventListener('input', () => {
                let val = parseFloat(upperRange.value);
                config.upperBound = val;

                if (config.lowerBound > val) {
                    config.lowerBound = val;
                    lowerRange.value = val;
                    lowerNum.value = val.toFixed(2);
                }
                
                upperNum.value = val.toFixed(2);
                drawSimulation();
            });

            upperNum.addEventListener('input', () => {
                const val = parseFloat(upperNum.value);
                if (!isNaN(val)) {
                    config.upperBound = val;
                    upperRange.value = val;

                    if (config.lowerBound > val) {
                        config.lowerBound = val;
                        lowerRange.value = val;
                        lowerNum.value = val.toFixed(2);
                    }
                    drawSimulation();
                }
            });

            upperNum.addEventListener('change', () => {
                let val = parseFloat(upperNum.value);
                const min = parseFloat(upperRange.min);
                const max = parseFloat(upperRange.max);

                if (isNaN(val)) val = max;
                val = Math.max(min, Math.min(max, val));
                config.upperBound = val;
                
                if (config.lowerBound > val) {
                    config.lowerBound = val;
                    lowerRange.value = val;
                    lowerNum.value = val.toFixed(2);
                }

                upperRange.value = val;
                upperNum.value = val.toFixed(2);
                drawSimulation();
            });


            div.querySelector(`#color-${config.id}`).addEventListener('input', (e) => {
                config.color = e.target.value;
                drawSimulation();
            });

            const widthInput = div.querySelector(`#width-${config.id}`);
            widthInput.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (!isNaN(val)) {
                    config.width = val;
                    drawSimulation();
                }
            });
            widthInput.addEventListener('change', (e) => {
                let val = parseFloat(e.target.value);
                const min = parseFloat(e.target.min);
                const max = parseFloat(e.target.max);
                if (isNaN(val)) val = min;
                const clampedVal = Math.max(min, Math.min(max, val));
                e.target.value = clampedVal.toFixed(1); // Correct precision for step=0.1
                config.width = clampedVal;
                drawSimulation();
            });

            return div;
        }

        function addNewEdgeConfig() {
            const newConfig = {
                id: `edgeConfig-${edgeConfigCounter++}`,
                lowerBound: 0, // units
                upperBound: 2, // units
                color: '#'+(Math.random()*0xFFFFFF<<0).toString(16).padStart(6, '0'), 
                width: 1.5,
                enabled: false // Edges are not plotted by default
            };
            edgeConfigs.push(newConfig);
            const configElement = createEdgeConfigHTML(newConfig);
            controls.interactionEdgeConfigsContainer.appendChild(configElement);
            drawSimulation();
        }

        function removeEdgeConfig(configId) {
            edgeConfigs = edgeConfigs.filter(config => config.id !== configId);
            const elementToRemove = document.getElementById(configId);
            if (elementToRemove) {
                controls.interactionEdgeConfigsContainer.removeChild(elementToRemove);
            }
            drawSimulation();
        }
        
        function initializeEdgeConfigs() {
            controls.interactionEdgeConfigsContainer.innerHTML = ''; 
            if (edgeConfigs.length === 0) {
                 addNewEdgeConfig(); 
            } else {
                 edgeConfigs.forEach(config => {
                    const configElement = createEdgeConfigHTML(config);
                    controls.interactionEdgeConfigsContainer.appendChild(configElement);
                });
            }
        }

        function drawInteractionLayer(L, allPrecomputedData, baseSpacing) {
            if (!controls.enableInteractions.checked) {
                lastRenderedInteractionPoints = []; 
                return;
            }

            const radiusInUnits = parseFloat(controls.distanceThreshold.value);
            const radiusPx = radiusInUnits * baseSpacing;
            const interactionPtSize = parseFloat(controls.interactionPointSize.value);
            const gamma = parseFloat(controls.colormapGamma.value);
            
            const numSides1 = parseInt(controls.interactionShape1.value);
            const rotationAngleRad1 = -(parseFloat(controls.interactionAngle1.value) * Math.PI / 180);
            const shiftX1 = parseFloat(controls.interactionShiftX1.value);
            const shiftY1 = parseFloat(controls.interactionShiftY1.value);
            const shiftX1_px = shiftX1 * radiusPx;
            const shiftY1_px = shiftY1 * radiusPx;

            const shape2Enabled = controls.enableShape2.checked;
            const numSides2 = parseInt(controls.interactionShape2.value);
            const rotationAngleRad2 = -(parseFloat(controls.interactionAngle2.value) * Math.PI / 180);
            const shiftX2 = parseFloat(controls.interactionShiftX2.value);
            const shiftY2 = parseFloat(controls.interactionShiftY2.value);
            const shiftX2_px = shiftX2 * radiusPx;
            const shiftY2_px = shiftY2 * radiusPx;

            const interactingLayersData = allPrecomputedData.filter(ld => ld.contributesToInteraction && ld.transformedPoints && ld.transformedPoints.length > 0);
            
            if (interactingLayersData.length < 2) { 
                 lastRenderedInteractionPoints = [];
                 return;
            }

            const redLayerData = interactingLayersData[0]; 
            const otherLayersData = interactingLayersData.slice(1); 
            const currentFrameInteractionPoints = []; 

            // --- Point Generation ---
            redLayerData.transformedPoints.forEach(rp => {
                let participatingNeighbors = [];
                let minDistanceToOtherLayer = Infinity;

                let polygonVertices1 = [];
                if (numSides1 > 0) {
                    const centerX1 = rp.x + shiftX1_px;
                    const centerY1 = rp.y - shiftY1_px; // FIX: Subtract to move up
                    for (let i = 0; i < numSides1; i++) {
                        const angle = (2 * Math.PI * i / numSides1) + rotationAngleRad1;
                        polygonVertices1.push({ x: centerX1 + radiusPx * Math.cos(angle), y: centerY1 + radiusPx * Math.sin(angle) });
                    }
                }
                
                let polygonVertices2 = [];
                if (shape2Enabled && numSides2 > 0) {
                    const centerX2 = rp.x + shiftX2_px;
                    const centerY2 = rp.y - shiftY2_px; // FIX: Subtract to move up
                    for (let i = 0; i < numSides2; i++) {
                        const angle = (2 * Math.PI * i / numSides2) + rotationAngleRad2;
                        polygonVertices2.push({ x: centerX2 + radiusPx * Math.cos(angle), y: centerY2 + radiusPx * Math.sin(angle) });
                    }
                }

                otherLayersData.forEach(otherLayer => {
                    let nearestNeighborThisLayer = null;
                    let minDistSqThisLayer = Infinity;

                    otherLayer.transformedPoints.forEach(op => {
                        let isInside = false;

                        // Check shape 1
                        if (numSides1 === 0) { // Circle
                           const distSq = Math.pow((rp.x + shiftX1_px) - op.x, 2) + Math.pow((rp.y - shiftY1_px) - op.y, 2); // FIX: Subtract to move up
                           if (distSq <= radiusPx * radiusPx) isInside = true;
                        } else { // Polygon
                           if (isPointInPolygon(op, polygonVertices1)) isInside = true;
                        }
                        
                        // Check shape 2 if enabled and not already inside
                        if (!isInside && shape2Enabled) {
                            if (numSides2 === 0) { // Circle
                                const distSq = Math.pow((rp.x + shiftX2_px) - op.x, 2) + Math.pow((rp.y - shiftY2_px) - op.y, 2); // FIX: Subtract to move up
                                if (distSq <= radiusPx * radiusPx) isInside = true;
                            } else { // Polygon
                                if (isPointInPolygon(op, polygonVertices2)) isInside = true;
                            }
                        }

                        if (isInside) {
                            const distSqToCenter = Math.pow(rp.x - op.x, 2) + Math.pow(rp.y - op.y, 2);
                            if (distSqToCenter < minDistSqThisLayer) {
                                minDistSqThisLayer = distSqToCenter;
                                nearestNeighborThisLayer = op;
                            }
                        }
                    });
                    
                    if (nearestNeighborThisLayer) {
                        participatingNeighbors.push(nearestNeighborThisLayer);
                        minDistanceToOtherLayer = Math.min(minDistanceToOtherLayer, Math.sqrt(minDistSqThisLayer));
                    }
                });

                if (participatingNeighbors.length > 0) {
                    let clusterPoints = [rp, ...participatingNeighbors]; 
                    let sumX = 0, sumY = 0;
                    clusterPoints.forEach(p => { sumX += p.x; sumY += p.y; });
                    const avgX = sumX / clusterPoints.length;
                    const avgY = sumY / clusterPoints.length;
                    const color = getColorForDistance(minDistanceToOtherLayer, radiusPx, gamma);
                    currentFrameInteractionPoints.push({x: avgX, y: avgY, color: color, distance: minDistanceToOtherLayer, id: `ip-${currentFrameInteractionPoints.length}`}); 
                }
            });
            
            // --- DRAWING LOGIC ---
            allDrawableEdges = []; 
            const anyFilterEnabled = edgeConfigs.some(c => c.enabled);

            if (anyFilterEnabled && currentFrameInteractionPoints.length >= 2) {
                const edgeMethod = controls.edgeMethod.value;
                const potentialEdgeIndices = (() => {
                    const indices = [];
                    if (edgeMethod === 'naive') {
                        for (let i = 0; i < currentFrameInteractionPoints.length; i++) {
                            for (let j = i + 1; j < currentFrameInteractionPoints.length; j++) {
                                indices.push([i, j]);
                            }
                        }
                    } else if (edgeMethod === 'delaunay' && currentFrameInteractionPoints.length > 2) {
                        const points = currentFrameInteractionPoints.map(p => [p.x, p.y]);
                        const delaunay = d3.Delaunay.from(points);
                        const drawnEdges = new Set();
                        const triangles = delaunay.triangles;
                        for (let i = 0; i < triangles.length; i += 3) {
                            const edgeGroup = [[triangles[i], triangles[i + 1]], [triangles[i + 1], triangles[i + 2]], [triangles[i + 2], triangles[i]]];
                            for (const [idx1, idx2] of edgeGroup) {
                                if (idx1 === undefined || idx2 === undefined) continue;
                                const key = `${Math.min(idx1, idx2)}-${Math.max(idx1, idx2)}`;
                                if (!drawnEdges.has(key)) {
                                    indices.push([idx1, idx2]);
                                    drawnEdges.add(key);
                                }
                            }
                        }
                    }
                    return indices;
                })();

                potentialEdgeIndices.forEach(([idx1, idx2]) => {
                    const p1 = currentFrameInteractionPoints[idx1];
                    const p2 = currentFrameInteractionPoints[idx2];
                    const id1_num = parseInt(p1.id.split('-')[1]);
                    const id2_num = parseInt(p2.id.split('-')[1]);
                    const edgeKey = `${Math.min(id1_num, id2_num)}-${Math.max(id1_num, id2_num)}`;
                    if (removedEdges.has(edgeKey)) return;
                    const distPx = calculateDistance(p1, p2);
                    const distUnits = baseSpacing > 0 ? distPx / baseSpacing : 0;
                    for (const config of edgeConfigs) {
                        if (config.enabled && distUnits >= config.lowerBound && distUnits <= config.upperBound) {
                            allDrawableEdges.push({ p1, p2, config, key: edgeKey });
                            break;
                        }
                    }
                });
            }

            ctx.globalAlpha = 0.7;
            allDrawableEdges.forEach(({ p1, p2, config }) => {
                ctx.strokeStyle = config.color;
                ctx.lineWidth = config.width;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });
            ctx.globalAlpha = 1.0;

            currentFrameInteractionPoints.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, interactionPtSize, 0, 2 * Math.PI);
                ctx.fill();
            });

            lastRenderedInteractionPoints = currentFrameInteractionPoints;
        }

        // --- Export Functionality ---
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportInteractionPoints() {
            if (lastRenderedInteractionPoints.length === 0) {
                showModalMessage("No interaction points to export. Ensure 'Enable Interaction Layer' is checked and layers are configured for interaction.");
                return;
            }
            let xyContent = "x_px,y_px\n"; 
            lastRenderedInteractionPoints.forEach(p => { xyContent += `${p.x.toFixed(3)},${p.y.toFixed(3)}\n`; });
            downloadFile("interaction_points_xy.txt", xyContent);
            let distanceContent = "distance_to_nearest_primary_px\n";
            lastRenderedInteractionPoints.forEach(p => { distanceContent += `${p.distance.toFixed(3)}\n`; });
            downloadFile("interaction_points_distances.txt", distanceContent);
        }
        
        // --- Settings Export/Import ---
        function exportSettings() {
            const settings = {
                globalSettings: {
                    latticeSize: controls.latticeSize.value,
                    baseSpacing: controls.baseSpacing.value,
                    numLayers: controls.numLayers.value,
                    pointSize: controls.pointSize.value,
                    interactionPointSize: controls.interactionPointSize.value,
                    colormapGamma: controls.colormapGamma.value,
                    enableInteractions: controls.enableInteractions.checked,
                    distanceThreshold: controls.distanceThreshold.value,
                    interactionShape1: controls.interactionShape1.value,
                    interactionAngle1: controls.interactionAngle1.value,
                    interactionShiftX1: controls.interactionShiftX1.value,
                    interactionShiftY1: controls.interactionShiftY1.value,
                    enableShape2: controls.enableShape2.checked,
                    interactionShape2: controls.interactionShape2.value,
                    interactionAngle2: controls.interactionAngle2.value,
                    interactionShiftX2: controls.interactionShiftX2.value,
                    interactionShiftY2: controls.interactionShiftY2.value,
                    edgeMethod: controls.edgeMethod.value,
                },
                layers: layers.map(l => {
                    const cleanLayer = { ...l };
                    delete cleanLayer.localPointsCache;
                    delete cleanLayer.transformedPointsCache;
                    return cleanLayer;
                }),
                edgeConfigs: edgeConfigs,
                removedEdges: Array.from(removedEdges)
            };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(settings, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "tiling_settings.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function importSettings() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedSettings = JSON.parse(event.target.result);
                        loadSettings(importedSettings);
                        showModalMessage("Settings loaded successfully!");
                    } catch (error) {
                        console.error("Failed to parse settings file:", error);
                        showModalMessage("Error: Could not load settings. The file may be corrupted or invalid.");
                    } finally {
                        fileInput.remove();
                    }
                };
                reader.onerror = () => {
                    showModalMessage("Error reading file.");
                    fileInput.remove();
                };
                reader.readAsText(file);
            });
            fileInput.click();
        }

        function loadSettings(settings) {
            const global = settings.globalSettings;
            if (global) {
                controls.latticeSize.value = global.latticeSize || 500;
                controls.baseSpacing.value = global.baseSpacing || 40;
                controls.numLayers.value = global.numLayers || 2;
                controls.pointSize.value = global.pointSize || 3;
                controls.interactionPointSize.value = global.interactionPointSize || 4;
                controls.colormapGamma.value = global.colormapGamma || 1.0;
                controls.colormapGammaNumber.value = global.colormapGamma || 1.0;
                controls.enableInteractions.checked = global.enableInteractions !== false;
                controls.distanceThreshold.value = global.distanceThreshold || 0.5;
                controls.distanceThresholdNumber.value = global.distanceThreshold || 0.5;
                
                controls.interactionShape1.value = global.interactionShape1 || 0;
                controls.interactionAngle1.value = global.interactionAngle1 || 0;
                controls.interactionAngleNumber1.value = global.interactionAngle1 || 0;
                controls.interactionShiftX1.value = global.interactionShiftX1 || 0;
                controls.interactionShiftXNumber1.value = global.interactionShiftX1 || 0;
                controls.interactionShiftY1.value = global.interactionShiftY1 || 0;
                controls.interactionShiftYNumber1.value = global.interactionShiftY1 || 0;
                
                controls.enableShape2.checked = global.enableShape2 || false;
                
                controls.interactionShape2.value = global.interactionShape2 || 0;
                controls.interactionAngle2.value = global.interactionAngle2 || 0;
                controls.interactionAngleNumber2.value = global.interactionAngle2 || 0;
                controls.interactionShiftX2.value = global.interactionShiftX2 || 0;
                controls.interactionShiftXNumber2.value = global.interactionShiftX2 || 0;
                controls.interactionShiftY2.value = global.interactionShiftY2 || 0;
                controls.interactionShiftYNumber2.value = global.interactionShiftY2 || 0;
                
                controls.edgeMethod.value = global.edgeMethod || 'naive';
                controls.distanceThresholdLabel.textContent = `Interaction Radius: ${parseFloat(global.distanceThreshold || 0.5).toFixed(3)}`;
                controls.colormapGammaLabel.textContent = `Colormap Sensitivity (γ): ${parseFloat(global.colormapGamma || 1.0).toFixed(2)}`;
                controls.interactionAngleLabel1.textContent = `Shape 1 Rotation: ${parseFloat(global.interactionAngle1 || 0).toFixed(1)}°`;
                controls.interactionShiftXLabel1.textContent = `Shape 1 Shift X: ${parseFloat(global.interactionShiftX1 || 0).toFixed(3)}`;
                controls.interactionShiftYLabel1.textContent = `Shape 1 Shift Y: ${parseFloat(global.interactionShiftY1 || 0).toFixed(3)}`;
                controls.interactionAngleLabel2.textContent = `Shape 2 Rotation: ${parseFloat(global.interactionAngle2 || 0).toFixed(1)}°`;
                controls.interactionShiftXLabel2.textContent = `Shape 2 Shift X: ${parseFloat(global.interactionShiftX2 || 0).toFixed(3)}`;
                controls.interactionShiftYLabel2.textContent = `Shape 2 Shift Y: ${parseFloat(global.interactionShiftY2 || 0).toFixed(3)}`;
            }

            if (settings.layers && Array.isArray(settings.layers)) {
                layers = settings.layers.map((l, index) => ({...getDefaultLayer(index), ...l, localPointsCache: null, transformedPointsCache: null }));
            } else {
                layers = []; updateNumberOfLayers();
            }

            if (settings.edgeConfigs && Array.isArray(settings.edgeConfigs)) {
                edgeConfigs = settings.edgeConfigs;
                edgeConfigCounter = edgeConfigs.length > 0 ? Math.max(...edgeConfigs.map(c => parseInt(c.id.split('-')[1]))) + 1 : 0;
            } else {
                edgeConfigs = [];
            }
            
            removedEdges = new Set(settings.removedEdges || []);
            
            handleSettingsChange();
            drawAllOrientations();
            drawColormapVisualization();
        }

        function showModalMessage(message) {
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '50%';
            modal.style.left = '50%';
            modal.style.transform = 'translate(-50%, -50%)';
            modal.style.backgroundColor = 'white';
            modal.style.padding = '20px';
            modal.style.borderRadius = '8px';
            modal.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
            modal.style.zIndex = '1000';
            modal.style.maxWidth = '300px';
            modal.style.textAlign = 'center';
            modal.innerHTML = `<p>${message}</p><button onclick="this.parentNode.remove()" style="margin-top: 15px;">OK</button>`;
            document.body.appendChild(modal);
        }

        const handleSettingsChange = () => {
            invalidateAllPointCaches(); 
            generateLayerControls(); 
            initializeEdgeConfigs();
            drawSimulation();
        };

        controls.latticeSize.addEventListener('input', () => {
            handleSettingsChange();
            resizeCanvasContainer(); 
        });
        controls.baseSpacing.addEventListener('input', handleSettingsChange);
        controls.numLayers.addEventListener('change', updateNumberOfLayers);
        controls.pointSize.addEventListener('input', drawSimulation); 
        controls.interactionPointSize.addEventListener('input', drawSimulation);
        
        // --- EVENT LISTENERS ---
        function drawColormapVisualization() {
            const gamma = parseFloat(controls.colormapGamma.value);
            const canvas = controls.colormapCanvas;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            for (let x = 0; x < w; x++) {
                const t = x / w;
                const t_gamma = Math.pow(t, gamma);
                ctx.strokeStyle = getViridisColor(t_gamma);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(0, h);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            for (let x = 0; x < w; x++) {
                const t = x / w;
                const t_gamma = Math.pow(t, gamma);
                const y = h - (t_gamma * h);
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.lineWidth = 1;
        }

        // Colormap Gamma Control
        const updateGamma = (val) => {
            controls.colormapGammaLabel.textContent = `Colormap Sensitivity (γ): ${parseFloat(val).toFixed(2)}`;
            drawColormapVisualization();
            drawSimulation();
        }
        controls.colormapGamma.addEventListener('input', (e) => {
            const val = e.target.value;
            controls.colormapGammaNumber.value = parseFloat(val).toFixed(2);
            updateGamma(val);
        });
        controls.colormapGammaNumber.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val)) {
                controls.colormapGamma.value = val;
                updateGamma(val);
            }
        });
        controls.colormapGammaNumber.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            const min = parseFloat(controls.colormapGamma.min);
            const max = parseFloat(controls.colormapGamma.max);
            if(isNaN(val)) val = 1.0;
            const clampedVal = Math.max(min, Math.min(max, val));
            e.target.value = clampedVal.toFixed(2);
            controls.colormapGamma.value = clampedVal;
            updateGamma(clampedVal);
        });


        // Interaction Radius
        controls.distanceThreshold.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            controls.distanceThresholdLabel.textContent = `Interaction Radius: ${val.toFixed(3)}`;
            controls.distanceThresholdNumber.value = val.toFixed(3);
            drawSimulation();
        });
        controls.distanceThresholdNumber.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (!isNaN(val)) {
                controls.distanceThreshold.value = val;
                controls.distanceThresholdLabel.textContent = `Interaction Radius: ${val}`;
                drawSimulation();
            }
        });
        controls.distanceThresholdNumber.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            const min = parseFloat(controls.distanceThreshold.min);
            const max = parseFloat(controls.distanceThreshold.max);
            if (isNaN(val)) val = min;
            const clampedVal = Math.max(min, Math.min(max, val));
            e.target.value = clampedVal.toFixed(3);
            controls.distanceThreshold.value = clampedVal;
            controls.distanceThresholdLabel.textContent = `Interaction Radius: ${clampedVal.toFixed(3)}`;
            drawSimulation();
        });

        controls.enableInteractions.addEventListener('change', drawSimulation);
        controls.addEdgeConfigButton.addEventListener('click', addNewEdgeConfig);

        function drawOrientationVisualization(vizCanvas, shapeSelect, angleInput, shiftXInput, shiftYInput) {
            const vizCtx = vizCanvas.getContext('2d');
            const w = vizCanvas.width, h = vizCanvas.height;
            const centerX = w / 2, centerY = h / 2, radius = w * 0.4;
            
            const numSides = parseInt(shapeSelect.value);
            const rotationAngleRad = -(parseFloat(angleInput.value) * Math.PI / 180);

            const shiftX = parseFloat(shiftXInput.value);
            const shiftY = parseFloat(shiftYInput.value);
            const vizShiftX = shiftX * radius;
            const vizShiftY = -shiftY * radius; // Invert Y for canvas coordinates
            const finalCenterX = centerX + vizShiftX;
            const finalCenterY = centerY + vizShiftY;

            vizCtx.clearRect(0, 0, w, h);
            // Draw crosshairs at the TRUE center
            vizCtx.strokeStyle = '#e0e0e0'; vizCtx.lineWidth = 1;
            vizCtx.beginPath(); vizCtx.moveTo(0, centerY); vizCtx.lineTo(w, centerY);
            vizCtx.moveTo(centerX, 0); vizCtx.lineTo(centerX, h); vizCtx.stroke();
            
            if (numSides === 0) { // Circle
                vizCtx.strokeStyle = '#333'; vizCtx.lineWidth = 2;
                vizCtx.beginPath(); vizCtx.arc(finalCenterX, finalCenterY, radius, 0, 2 * Math.PI); vizCtx.stroke();
            } else if (numSides > 0) { // Polygon
                vizCtx.strokeStyle = '#333'; vizCtx.lineWidth = 2;
                vizCtx.beginPath();
                for (let i = 0; i <= numSides; i++) {
                    const angle = (2 * Math.PI * i / numSides) + rotationAngleRad;
                    const x = finalCenterX + radius * Math.cos(angle); const y = finalCenterY + radius * Math.sin(angle);
                    if (i === 0) vizCtx.moveTo(x, y); else vizCtx.lineTo(x, y);
                }
                vizCtx.stroke();
                
                // Draw line from center to first vertex
                const firstVertexAngle = rotationAngleRad;
                const firstVertexX = finalCenterX + radius * Math.cos(firstVertexAngle);
                const firstVertexY = finalCenterY + radius * Math.sin(firstVertexAngle);
                vizCtx.strokeStyle = 'red'; vizCtx.lineWidth = 2;
                vizCtx.beginPath(); vizCtx.moveTo(finalCenterX, finalCenterY); vizCtx.lineTo(firstVertexX, firstVertexY); vizCtx.stroke();
            }
        }
        
        const drawAllOrientations = () => {
            drawOrientationVisualization(document.getElementById('orientationCanvas1'), controls.interactionShape1, controls.interactionAngle1, controls.interactionShiftX1, controls.interactionShiftY1);
            const canvas2 = document.getElementById('orientationCanvas2');
            canvas2.style.display = controls.enableShape2.checked ? 'inline-block' : 'none';
            if (controls.enableShape2.checked) {
                drawOrientationVisualization(canvas2, controls.interactionShape2, controls.interactionAngle2, controls.interactionShiftX2, controls.interactionShiftY2);
            }
        };

        // Helper function for setting up paired range/number inputs in advanced controls
        function setupAdvancedControlListeners(range, number, label, prefix, suffix, precision) {
            const update = (val) => {
                label.textContent = `${prefix} ${val.toFixed(precision)}${suffix}`;
                drawAllOrientations();
                drawSimulation();
            };

            range.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                number.value = v.toFixed(precision);
                update(v);
            });

            number.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                if (!isNaN(v)) {
                    range.value = v;
                    label.textContent = `${prefix} ${v}${suffix}`;
                    drawAllOrientations();
                    drawSimulation();
                }
            });
            
            number.addEventListener('change', (e) => {
                let v = parseFloat(e.target.value);
                const min = parseFloat(range.min);
                const max = parseFloat(range.max);
                if (isNaN(v)) v = 0;
                const cV = Math.max(min, Math.min(max, v));
                e.target.value = cV.toFixed(precision);
                range.value = cV;
                update(cV);
            });
        }
        
        controls.interactionShape1.addEventListener('change', () => { drawAllOrientations(); drawSimulation(); });
        setupAdvancedControlListeners(controls.interactionAngle1, controls.interactionAngleNumber1, controls.interactionAngleLabel1, 'Shape 1 Rotation:', '°', 1);
        setupAdvancedControlListeners(controls.interactionShiftX1, controls.interactionShiftXNumber1, controls.interactionShiftXLabel1, 'Shape 1 Shift X:', '', 3);
        setupAdvancedControlListeners(controls.interactionShiftY1, controls.interactionShiftYNumber1, controls.interactionShiftYLabel1, 'Shape 1 Shift Y:', '', 3);

        controls.enableShape2.addEventListener('change', (e) => {
            controls.shape2Controls.style.display = e.target.checked ? 'block' : 'none';
            drawAllOrientations(); drawSimulation();
        });
        controls.interactionShape2.addEventListener('change', () => { drawAllOrientations(); drawSimulation(); });
        setupAdvancedControlListeners(controls.interactionAngle2, controls.interactionAngleNumber2, controls.interactionAngleLabel2, 'Shape 2 Rotation:', '°', 1);
        setupAdvancedControlListeners(controls.interactionShiftX2, controls.interactionShiftXNumber2, controls.interactionShiftXLabel2, 'Shape 2 Shift X:', '', 3);
        setupAdvancedControlListeners(controls.interactionShiftY2, controls.interactionShiftYNumber2, controls.interactionShiftYLabel2, 'Shape 2 Shift Y:', '', 3);
        

        controls.edgeMethod.addEventListener('change', drawSimulation);

        function handleCanvasClick(event) {
            if (!event.ctrlKey || event.button !== 0) return;
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
            const clickPoint = { x: (event.clientX - rect.left) * scaleX, y: (event.clientY - rect.top) * scaleY };
            let closestEdge = null, minDistance = Infinity;
            const clickThreshold = 5;
            allDrawableEdges.forEach(edge => {
                const distance = getDistanceToSegment(clickPoint, edge.p1, edge.p2);
                if (distance < minDistance) { minDistance = distance; closestEdge = edge; }
            });
            if (closestEdge && minDistance < clickThreshold) {
                removedEdges.add(closestEdge.key);
                drawSimulation();
            }
        }

        function resizeCanvasContainer() {
            const controlPanelWidth = document.getElementById('controls').offsetWidth;
            const padding = 40; 
            const availableWidth = window.innerWidth - controlPanelWidth - padding; 
            const availableHeight = window.innerHeight - padding; 
            const L = parseInt(controls.latticeSize.value); 
            let displayScale = 1;
            if (L > 0) { 
                if (L > availableWidth || L > availableHeight) {
                    displayScale = Math.min(availableWidth / L, availableHeight / L);
                }
                displayScale = Math.max(0.1, displayScale); 
            } else { 
                displayScale = 1; 
            }
            canvas.style.width = (L * displayScale) + 'px';
            canvas.style.height = (L * displayScale) + 'px';
        }

        function populateInteractionShapes(selectElement) {
            const shapes = [
                { name: 'Circle', sides: 0 }, { name: 'Square', sides: 4 },
                { name: 'Pentagon', sides: 5 }, { name: 'Hexagon', sides: 6 },
                { name: 'Heptagon', sides: 7 }, { name: 'Octagon', sides: 8 },
                { name: 'Nonagon', sides: 9 }, { name: 'Decagon', sides: 10 },
                { name: 'Hendecagon', sides: 11 }, { name: 'Dodecagon', sides: 12 }
            ];
            selectElement.innerHTML = '';
            shapes.forEach(shape => {
                const option = document.createElement('option');
                option.value = shape.sides;
                option.textContent = shape.sides === 0 ? `${shape.name} (Default)` : `${shape.name} (${shape.sides})`;
                selectElement.appendChild(option);
            });
        }

        function showInfoModal() {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const content = document.createElement('div');
            content.className = 'modal-content';

            content.innerHTML = `
                <h2>About This Simulation</h2>
                <p>This tool visualizes the Moiré-like patterns that emerge from overlapping periodic tilings or point sets, and implements the "near coincidence method to generate quasiperiodic tilings."</p>
                <h3>Core Concepts</h3>
                <ul>
                    <li><strong>Layers:</strong> Each colored layer (red, blue, etc.) is a 2D set of points (square, triangular, or honeycomb). You can control each layer's rotation, scale, and shift.</li>
                    <li><strong>Interaction Layer:</strong> This is the main visualization. It shows new points that are generated where points from different base layers are very close to each other ("nearly coincident"). The color of these interaction points indicates how close the original points were.</li>
                </ul>
                <h3>Key Controls</h3>
                <ul>
                    <li><strong>Global Settings:</strong> Control the overall size, spacing, and the sensitivity of the interaction point colormap (the γ slider).</li>
                    <li><strong>Interaction Layer Settings:</strong> The "Interaction Radius" defines how close points must be to be considered for an interaction. The "Advanced Settings" allow you to define the shape (circle, polygon, etc.) and position of the search area around each point of the first layer.</li>
                    <li><strong>Edge Filters:</strong> These allow you to draw lines connecting interaction points that are within a specific distance range from each other. This is a powerful tool for revealing the new periodic or quasi-periodic tilings formed by the interaction points.</li>
                </ul>
                 <h3>Special Interactions</h3>
                 <ul>
                    <li><strong>Remove Edge:</strong> Hold down the <strong>Ctrl</strong> key and <strong>click</strong> on an edge in the main canvas to temporarily remove it. You can restore all removed edges with the button in the "Edge Filters" section.</li>
                 </ul>
                <button id="closeModalButton">Close</button>
            `;

            overlay.appendChild(content);
            document.body.appendChild(overlay);

            const closeModal = () => document.body.removeChild(overlay);
            overlay.addEventListener('click', (e) => { if(e.target === overlay) closeModal(); });
            content.querySelector('#closeModalButton').addEventListener('click', closeModal);
        }


        function initialSetup() {
            populateInteractionShapes(controls.interactionShape1);
            populateInteractionShapes(controls.interactionShape2);
            updateNumberOfLayers(); 
            initializeEdgeConfigs(); 
            resizeCanvasContainer();
            drawAllOrientations();
            drawColormapVisualization();

            controls.infoButton.addEventListener('click', showInfoModal);
            document.getElementById('restoreEdgesButton').addEventListener('click', () => {
                removedEdges.clear();
                drawSimulation();
            });
            canvas.addEventListener('click', handleCanvasClick);
        }
        
        controls.exportSettingsButton.addEventListener('click', exportSettings);
        controls.importSettingsButton.addEventListener('click', importSettings);
        controls.exportInteractionPointsButton.addEventListener('click', exportInteractionPoints);

        window.addEventListener('resize', resizeCanvasContainer);
        window.addEventListener('load', initialSetup);
        
    </script></body>
</html>