<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lattice Superposition & Interaction Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: #f0f0f0;
        }

        #controls {
            width: 380px; 
            padding: 20px;
            background-color: #fff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            height: 100vh;
            box-sizing: border-box;
        }

        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background-color: #e9e9e9;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: white;
            max-width: 100%;
            max-height: 100%;
        }

        .control-group {
            margin-bottom: 15px; 
            border-bottom: 1px solid #eee;
            padding-bottom: 10px; 
        }

        .control-group:last-child {
            border-bottom: none;
        }
         .edge-config-item {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: #f9f9f9;
        }


        h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }

        h4 {
            margin-top: 15px;
            margin-bottom: 5px;
            color: #555;
        }
         h4 .layer-color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #777;
        }


        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #666;
        }
        .label-inline {
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }

        input[type="number"],
        select,
        button,
        input[type="color"] { 
            width: calc(100% - 12px);
            padding: 8px; 
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        input[type="color"] {
             width: calc(100% - 22px); 
             padding: 5px;
             height: 35px; 
        }
        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.add-button {
            background-color: #28a745; /* Green */
            margin-top: 5px;
        }
        button.add-button:hover {
            background-color: #218838;
        }
        button.remove-button {
            background-color: #dc3545; /* Red */
            font-size: 0.8em;
            padding: 5px 8px;
            width: auto; /* Fit content */
            margin-top: 5px;
            float: right; /* Align remove button to the right */
        }
        button.remove-button:hover {
            background-color: #c82333;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .input-group input[type="range"] {
            flex-grow: 1;
            padding: 0;
            margin-bottom: 0; 
        }

        .input-group input[type="number"] {
            width: 70px; 
            margin-bottom: 0; 
        }


        input[type="range"] {
            width: 100%; 
            padding: 0;
             margin-bottom: 10px;
        }
        input[type="checkbox"]{
            vertical-align: middle;
            width: auto;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <h3>Global Settings</h3>
            <label for="latticeSize">Lattice Area Size (L x L pixels):</label>
            <input type="number" id="latticeSize" value="500" min="100" max="800">
            
            <label for="baseSpacing">Base Lattice Spacing (px):</label>
            <input type="number" id="baseSpacing" value="40" min="10" max="100">

            <label for="numLayers">Number of Layers:</label>
            <select id="numLayers">
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>

            <label for="pointSize">Base Layer Point Size (radius, px):</label>
            <input type="number" id="pointSize" value="3" min="0.5" max="10" step="0.5">
            
            <label for="interactionPointSize">Interaction Point Size (radius, px):</label>
            <input type="number" id="interactionPointSize" value="4" min="0.5" max="10" step="0.5">
        </div>
        
        <div class="control-group">
            <h3>Interaction Layer Settings</h3>
            <div>
                <input type="checkbox" id="enableInteractions" checked>
                <label for="enableInteractions" class="label-inline">Enable Interaction Layer</label>
            </div>
            <label id="distanceThresholdLabel" for="distanceThresholdNumber" style="margin-top:10px;">Point Distance Threshold: 0.50</label>
             <div class="input-group">
                <input type="range" id="distanceThreshold" value="0.5" min="0.001" max="1" step="0.001">
                <input type="number" id="distanceThresholdNumber" value="0.5" min="0.001" max="1" step="0.001">
            </div>

            <h4>Interaction Edges</h4>
            <div id="interaction-edge-configs-container">
                </div>
            <button id="add-edge-config-button" class="add-button">+ Add Edge Type</button>
            
            <button id="exportInteractionPointsButton" style="margin-top: 15px;">Export Interaction Points (TXT)</button>
        </div>


        <div id="layers-controls-container">
            </div>
    </div>

    <div id="canvas-container">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        const controls = {
            latticeSize: document.getElementById('latticeSize'),
            baseSpacing: document.getElementById('baseSpacing'),
            numLayers: document.getElementById('numLayers'),
            pointSize: document.getElementById('pointSize'),
            interactionPointSize: document.getElementById('interactionPointSize'),
            layersControlsContainer: document.getElementById('layers-controls-container'),
            distanceThreshold: document.getElementById('distanceThreshold'),
            distanceThresholdNumber: document.getElementById('distanceThresholdNumber'),
            distanceThresholdLabel: document.getElementById('distanceThresholdLabel'),
            enableInteractions: document.getElementById('enableInteractions'),
            exportInteractionPointsButton: document.getElementById('exportInteractionPointsButton'),
            interactionEdgeConfigsContainer: document.getElementById('interaction-edge-configs-container'),
            addEdgeConfigButton: document.getElementById('add-edge-config-button')
        };

        const layerColors = ['red', 'blue', 'green', 'orange'];
        let layers = [];
        let lastRenderedInteractionPoints = []; 
        let edgeConfigs = [];
        let edgeConfigCounter = 0; 

        // --- Viridis Colormap ---
        const viridisColormap = [
            { t: 0.0,  rgb: [68,  1,   84] },  { t: 0.1,  rgb: [72,  40,  120] }, 
            { t: 0.2,  rgb: [62,  74,  137] }, { t: 0.3,  rgb: [49,  104, 142] },
            { t: 0.4,  rgb: [38,  130, 142] }, { t: 0.5,  rgb: [31,  158, 137] },
            { t: 0.6,  rgb: [53,  183, 121] }, { t: 0.7,  rgb: [109, 205,  89] },
            { t: 0.8,  rgb: [180, 222,  44] }, { t: 0.9,  rgb: [248, 231,  28] },
            { t: 1.0,  rgb: [253, 231,  37] }
        ];

        function getViridisColor(t) {
            t = Math.max(0, Math.min(1, t)); 
            for (let i = 0; i < viridisColormap.length - 1; i++) {
                const c1 = viridisColormap[i]; const c2 = viridisColormap[i+1];
                if (t >= c1.t && t <= c2.t) {
                    const local_t = (t - c1.t) / (c2.t - c1.t);
                    const r = Math.round(c1.rgb[0] * (1 - local_t) + c2.rgb[0] * local_t);
                    const g = Math.round(c1.rgb[1] * (1 - local_t) + c2.rgb[1] * local_t);
                    const b = Math.round(c1.rgb[2] * (1 - local_t) + c2.rgb[2] * local_t);
                    return `rgb(${r},${g},${b})`;
                }
            }
            const lastColor = viridisColormap[viridisColormap.length - 1].rgb;
            return `rgb(${lastColor[0]},${lastColor[1]},${lastColor[2]})`;
        }

        // --- Point Generation Functions ---
        function generateSquareLatticePoints(size, spacing) {
            const points = []; if (spacing <= 0) return points;
            const numStepsHalf = Math.ceil(size / (2 * spacing));
            for (let i = -numStepsHalf; i <= numStepsHalf; i++) {
                const x = i * spacing;
                for (let j = -numStepsHalf; j <= numStepsHalf; j++) {
                    const y = j * spacing; points.push({ x, y });
                }
            }
            return points;
        }

        function generateTriangularLatticePoints(size, spacing) {
            const points = []; if (spacing <= 0) return points;
            const h = spacing * Math.sqrt(3) / 2; if (h <= 0) return points; 
            const numYRowsHalf = Math.ceil(size / (2 * h));
            const numXPointsHalf = Math.ceil(size / (2 * spacing));
            for (let j = -numYRowsHalf; j <= numYRowsHalf; j++) {
                const y = j * h; const isOffsetRow = (Math.abs(j) % 2 === 1); 
                for (let k = -numXPointsHalf; k <= numXPointsHalf; k++) {
                    let x = k * spacing; if (isOffsetRow) { x += spacing / 2; }
                    points.push({ x, y });
                }
            }
            return points;
        }

        function generateHoneycombPointLatticePoints(size, sideLength) {
            const rawPoints = []; 
            if (sideLength <= 0) return rawPoints;
            const hexWidth = Math.sqrt(3) * sideLength; 
            const hexHeight = 2 * sideLength;      
            const vertSpacing = hexHeight * 3/4; 
            const horizSpacing = hexWidth;       
            const numRowsForLoop = Math.ceil((size / vertSpacing) / 2) + 2; 
            const numColsForLoop = Math.ceil((size / horizSpacing) / 2) + 2; 
            const uniqueVertices = new Set(); 
            for (let r = -numRowsForLoop; r <= numRowsForLoop; r++) {
                for (let c = -numColsForLoop; c <= numColsForLoop; c++) {
                    const xCenter = c * horizSpacing + (Math.abs(r) % 2 === 1 ? horizSpacing / 2 : 0); 
                    const yCenter = r * vertSpacing;
                    for (let i = 0; i < 6; i++) {
                        const angle_rad = (Math.PI / 3) * i + Math.PI / 6; 
                        const vx = xCenter + sideLength * Math.cos(angle_rad); 
                        const vy = yCenter + sideLength * Math.sin(angle_rad);
                        const key = `${vx.toFixed(3)},${vy.toFixed(3)}`; 
                        if (!uniqueVertices.has(key)) { 
                            rawPoints.push({ x: vx, y: vy }); 
                            uniqueVertices.add(key);
                        }
                    }
                }
            }
            if (rawPoints.length === 0) return [];
            let closestPoint = rawPoints[0];
            let minDistanceSq = closestPoint.x * closestPoint.x + closestPoint.y * closestPoint.y;
            for (let i = 1; i < rawPoints.length; i++) {
                const p = rawPoints[i];
                const distSq = p.x * p.x + p.y * p.y;
                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestPoint = p;
                }
            }
            const shiftX = -closestPoint.x; const shiftY = -closestPoint.y;
            return rawPoints.map(p => ({ x: p.x + shiftX, y: p.y + shiftY }));
        }

        // --- Transformation and Utility Functions ---
        function transformPoint(point, L, layerConfig, baseSpacing) {
            let { x, y } = point; 
            x *= layerConfig.scale; y *= layerConfig.scale;
            const angleRad = layerConfig.angle * Math.PI / 180;
            const cosA = Math.cos(angleRad); const sinA = Math.sin(angleRad);
            const rotatedX = x * cosA - y * sinA; const rotatedY = x * sinA + y * cosA;
            // Shifts are in units, convert to pixels
            const shiftX_px = layerConfig.shiftX * baseSpacing;
            const shiftY_px = layerConfig.shiftY * baseSpacing;
            return { x: L / 2 + rotatedX + shiftX_px, y: L / 2 + rotatedY + shiftY_px };
        }
        
        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function getColorForDistanceViridisLog(distance, threshold_px) {
            const epsilon = 0.001; 
            const val = -distance; 
            const val_max = -epsilon; 
            const val_min = -threshold_px; 
            let normalized_val = (val_max === val_min) ? 0.5 : (val - val_min) / (val_max - val_min);
            normalized_val = 1 - Math.max(0, Math.min(1, normalized_val)); 
            return getViridisColor(normalized_val);
        }

        // --- Layer Control Generation ---
        function getDefaultLayer(index, type = 'square') {
             return {
                id: `layer-${index + 1}`, type,
                color: layerColors[index % layerColors.length],
                angle: 0, scale: 1.0, 
                shiftX: 0, // in units
                shiftY: 0, // in units
                visible: true,
                contributesToInteraction: true,
                alpha: 0.3, 
                localPointsCache: null, transformedPointsCache: null 
            };
        }

        function updateNumberOfLayers() {
            const num = parseInt(controls.numLayers.value);
            const currentGlobalType = layers.length > 0 && layers[0].type ? layers[0].type : 'square'; 
            const newLayers = [];
            for (let i = 0; i < num; i++) {
                if (layers[i]) { 
                    newLayers.push(layers[i]);
                } else { 
                    newLayers.push(getDefaultLayer(i, currentGlobalType));
                }
            }
            layers = newLayers.slice(0, num); 
            generateLayerControls(); 
            invalidateAllPointCaches(); 
            drawSimulation(); 
        }
        
        function invalidateAllPointCaches() {
            layers.forEach(l => { l.localPointsCache = null; l.transformedPointsCache = null;});
        }

        function invalidateLayerPointCache(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) { layer.localPointsCache = null; layer.transformedPointsCache = null;}
        }

        function generateLayerControls() {
            controls.layersControlsContainer.innerHTML = ''; 
            const L = parseInt(controls.latticeSize.value);
            const baseSpacing = parseFloat(controls.baseSpacing.value);
            const maxShiftUnits = baseSpacing > 0 ? 1 : 0; //(L / 2) / baseSpacing

            layers.forEach((layer, index) => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-controls control-group';
                layerDiv.id = `controls-${layer.id}`;
                const colorIndicator = `<span class="layer-color-indicator" style="background-color: ${layer.color};"></span>`;
                layerDiv.innerHTML = `<h4>${colorIndicator}Layer ${index + 1} (${layer.color})</h4>`;
                
                const typeLabel = document.createElement('label'); typeLabel.textContent = 'Lattice Type:';
                const typeSelect = document.createElement('select'); typeSelect.id = `type-${layer.id}`;
                ['square', 'triangular', 'honeycomb'].forEach(type => {
                    const option = document.createElement('option'); option.value = type; option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    if (type === layer.type) option.selected = true; typeSelect.appendChild(option);
                });
                typeSelect.addEventListener('change', (e) => { layer.type = e.target.value; invalidateLayerPointCache(layer.id); drawSimulation(); });
                layerDiv.appendChild(typeLabel); layerDiv.appendChild(typeSelect);

                // Angle
                const angleGroup = document.createElement('div'); angleGroup.className = 'input-group';
                const angleLabel = document.createElement('label'); angleLabel.textContent = `Angle: ${layer.angle.toFixed(1)}°`;
                const angleInput = document.createElement('input'); angleInput.type = 'range'; angleInput.min = -180; angleInput.max = 180; angleInput.value = layer.angle; angleInput.step = 0.1;
                const angleNumberInput = document.createElement('input'); angleNumberInput.type = 'number'; angleNumberInput.min = -180; angleNumberInput.max = 180; angleNumberInput.value = layer.angle.toFixed(1); angleNumberInput.step = 0.1;
                const angleUpdate = (val) => { layer.angle = val; angleLabel.textContent = `Angle: ${val.toFixed(1)}°`; invalidateLayerPointCache(layer.id); drawSimulation(); };
                angleInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); angleNumberInput.value = v.toFixed(1); angleUpdate(v); });
                angleNumberInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); if(isNaN(v)) return; const cV = Math.max(-180, Math.min(180,v)); angleInput.value = cV.toFixed(1); if(v.toFixed(1) !== cV.toFixed(1)) e.target.value = cV.toFixed(1); angleUpdate(cV); });
                layerDiv.appendChild(angleLabel); angleGroup.appendChild(angleInput); angleGroup.appendChild(angleNumberInput); layerDiv.appendChild(angleGroup);

                // Scale
                const scaleGroup = document.createElement('div'); scaleGroup.className = 'input-group';
                const scaleLabel = document.createElement('label'); scaleLabel.textContent = `Scale: ${layer.scale.toFixed(2)}`;
                const scaleInput = document.createElement('input'); scaleInput.type = 'range'; scaleInput.min = 0.1; scaleInput.max = 3; scaleInput.value = layer.scale; scaleInput.step = 0.01;
                const scaleNumberInput = document.createElement('input'); scaleNumberInput.type = 'number'; scaleNumberInput.min = 0.1; scaleNumberInput.max = 3; scaleNumberInput.value = layer.scale.toFixed(2); scaleNumberInput.step = 0.01;
                const scaleUpdate = (val) => { layer.scale = val; scaleLabel.textContent = `Scale: ${val.toFixed(2)}`; invalidateLayerPointCache(layer.id); drawSimulation(); };
                scaleInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); scaleNumberInput.value = v.toFixed(2); scaleUpdate(v); });
                scaleNumberInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); if(isNaN(v)) return; const cV = Math.max(0.1, Math.min(3,v)); scaleInput.value = cV.toFixed(2); if(v.toFixed(2) !== cV.toFixed(2)) e.target.value = cV.toFixed(2); scaleUpdate(cV); });
                layerDiv.appendChild(scaleLabel); scaleGroup.appendChild(scaleInput); scaleGroup.appendChild(scaleNumberInput); layerDiv.appendChild(scaleGroup);
                
                // Shift X (units)
                const shiftXGroup = document.createElement('div'); shiftXGroup.className = 'input-group';
                const shiftXLabel = document.createElement('label'); shiftXLabel.textContent = `Shift X: ${layer.shiftX.toFixed(2)}`;
                const shiftXRange = document.createElement('input'); shiftXRange.type = 'range'; shiftXRange.min = -maxShiftUnits.toFixed(2); shiftXRange.max = maxShiftUnits.toFixed(2); shiftXRange.value = layer.shiftX; shiftXRange.step = 0.01;
                const shiftXNumber = document.createElement('input'); shiftXNumber.type = 'number'; shiftXNumber.min = -maxShiftUnits.toFixed(2); shiftXNumber.max = maxShiftUnits.toFixed(2); shiftXNumber.value = layer.shiftX.toFixed(2); shiftXNumber.step = 0.01;
                const shiftXUpdate = (val) => {
                    layer.shiftX = val;
                    shiftXLabel.textContent = `Shift X: ${val.toFixed(2)}`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                shiftXRange.addEventListener('input', (e) => { const v = parseFloat(e.target.value); shiftXNumber.value = v.toFixed(2); shiftXUpdate(v); });
                shiftXNumber.addEventListener('input', (e) => { 
                    let v = parseFloat(e.target.value); if(isNaN(v)) v = 0;
                    v = Math.max(parseFloat(shiftXRange.min), Math.min(parseFloat(shiftXRange.max), v));
                    e.target.value = v.toFixed(2); shiftXRange.value = v; shiftXUpdate(v); 
                });
                layerDiv.appendChild(shiftXLabel); shiftXGroup.appendChild(shiftXRange); shiftXGroup.appendChild(shiftXNumber); layerDiv.appendChild(shiftXGroup);
                
                // Shift Y (units)
                const shiftYGroup = document.createElement('div'); shiftYGroup.className = 'input-group';
                const shiftYLabel = document.createElement('label'); shiftYLabel.textContent = `Shift Y: ${layer.shiftY.toFixed(2)}`;
                const shiftYRange = document.createElement('input'); shiftYRange.type = 'range'; shiftYRange.min = -maxShiftUnits.toFixed(2); shiftYRange.max = maxShiftUnits.toFixed(2); shiftYRange.value = layer.shiftY; shiftYRange.step = 0.05;
                const shiftYNumber = document.createElement('input'); shiftYNumber.type = 'number'; shiftYNumber.min = -maxShiftUnits.toFixed(2); shiftYNumber.max = maxShiftUnits.toFixed(2); shiftYNumber.value = layer.shiftY.toFixed(2); shiftYNumber.step = 0.05;
                const shiftYUpdate = (val) => {
                    layer.shiftY = val;
                    shiftYLabel.textContent = `Shift Y: ${val.toFixed(2)}`;
                    invalidateLayerPointCache(layer.id);
                    drawSimulation();
                };
                shiftYRange.addEventListener('input', (e) => { const v = parseFloat(e.target.value); shiftYNumber.value = v.toFixed(2); shiftYUpdate(v); });
                shiftYNumber.addEventListener('input', (e) => { 
                    let v = parseFloat(e.target.value); if(isNaN(v)) v = 0;
                     v = Math.max(parseFloat(shiftYRange.min), Math.min(parseFloat(shiftYRange.max), v));
                    e.target.value = v.toFixed(2); shiftYRange.value = v; shiftYUpdate(v); 
                });
                layerDiv.appendChild(shiftYLabel); shiftYGroup.appendChild(shiftYRange); shiftYGroup.appendChild(shiftYNumber); layerDiv.appendChild(shiftYGroup);

                // Alpha
                const alphaGroup = document.createElement('div'); alphaGroup.className = 'input-group';
                const alphaLabel = document.createElement('label'); alphaLabel.textContent = `Alpha: ${layer.alpha.toFixed(2)}`;
                const alphaInput = document.createElement('input'); alphaInput.type = 'range'; alphaInput.min = 0; alphaInput.max = 1; alphaInput.value = layer.alpha; alphaInput.step = 0.01;
                const alphaNumberInput = document.createElement('input'); alphaNumberInput.type = 'number'; alphaNumberInput.min = 0; alphaNumberInput.max = 1; alphaNumberInput.value = layer.alpha.toFixed(2); alphaNumberInput.step = 0.01;
                const alphaUpdate = (val) => { layer.alpha = val; alphaLabel.textContent = `Alpha: ${val.toFixed(2)}`; drawSimulation(); }; 
                alphaInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); alphaNumberInput.value = v.toFixed(2); alphaUpdate(v); });
                alphaNumberInput.addEventListener('input', (e) => { const v = parseFloat(e.target.value); if(isNaN(v)) return; const cV = Math.max(0, Math.min(1,v)); alphaInput.value = cV.toFixed(2); if(v.toFixed(2) !== cV.toFixed(2)) e.target.value = cV.toFixed(2); alphaUpdate(cV); });
                layerDiv.appendChild(alphaLabel); alphaGroup.appendChild(alphaInput); alphaGroup.appendChild(alphaNumberInput); layerDiv.appendChild(alphaGroup);
                
                // Visibility and Interaction Checkboxes
                const visibleLabel = document.createElement('label');
                const visibleCheckbox = document.createElement('input');
                visibleCheckbox.type = 'checkbox';
                visibleCheckbox.checked = layer.visible;
                visibleCheckbox.addEventListener('change', (e) => { 
                    layer.visible = e.target.checked;
                    drawSimulation(); 
                }); 
                visibleLabel.appendChild(visibleCheckbox);
                visibleLabel.append(` Visible`);
                layerDiv.appendChild(visibleLabel);

                const interactionLabel = document.createElement('label');
                const interactionCheckbox = document.createElement('input');
                interactionCheckbox.type = 'checkbox';
                interactionCheckbox.checked = layer.contributesToInteraction;
                interactionCheckbox.addEventListener('change', (e) => {
                    layer.contributesToInteraction = e.target.checked;
                    drawSimulation();
                });
                interactionLabel.appendChild(interactionCheckbox);
                interactionLabel.append(' Contributes to Interaction');
                layerDiv.appendChild(interactionLabel);
                
                controls.layersControlsContainer.appendChild(layerDiv);
            });
        }
        
        // --- Main Drawing Logic ---
        function drawSimulation() {
            const L = parseInt(controls.latticeSize.value);
            const baseSpacing = parseFloat(controls.baseSpacing.value);
            if(isNaN(L) || isNaN(baseSpacing) || baseSpacing <= 0) return;

            canvas.width = L; 
            canvas.height = L;
            const mainPointSize = parseFloat(controls.pointSize.value);
            
            let minEffectiveScale = 1;
            const contributingLayers = layers.filter(l => l.contributesToInteraction);
            if (contributingLayers.length > 0) {
                 minEffectiveScale = Math.min(...contributingLayers.map(l => l.scale));
            }
            const drawL = L * 1.8 / Math.max(0.1, minEffectiveScale); 

            ctx.clearRect(0, 0, L, L); 
            let currentFramePrecomputedData = []; 

            layers.forEach(layerConfig => {
                let localPts = layerConfig.localPointsCache;
                let transformedPts = layerConfig.transformedPointsCache;
                if (!localPts) { 
                    switch (layerConfig.type) {
                        case 'square': localPts = generateSquareLatticePoints(drawL, baseSpacing); break;
                        case 'triangular': localPts = generateTriangularLatticePoints(drawL, baseSpacing); break;
                        // For honeycomb, the 'spacing' is the side length.
                        case 'honeycomb': localPts = generateHoneycombPointLatticePoints(drawL, baseSpacing / Math.sqrt(3) * 2 / 2 ); break; 
                        default: localPts = [];
                    }
                    layerConfig.localPointsCache = localPts;
                    layerConfig.transformedPointsCache = null; // Invalidate transformed cache
                }
                
                if (!layerConfig.transformedPointsCache) { 
                     transformedPts = localPts.map(p => transformPoint(p, L, layerConfig, baseSpacing));
                     layerConfig.transformedPointsCache = transformedPts;
                } else {
                    transformedPts = layerConfig.transformedPointsCache;
                }

                currentFramePrecomputedData.push({ ...layerConfig, transformedPoints: transformedPts });
                
                if (layerConfig.visible) {
                    ctx.globalAlpha = layerConfig.alpha; 
                    ctx.fillStyle = layerConfig.color;
                    transformedPts.forEach(p => {
                        if (p.x >= -mainPointSize && p.x <= L + mainPointSize && p.y >= -mainPointSize && p.y <= L + mainPointSize) {
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, mainPointSize, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                    });
                }
            });

            ctx.globalAlpha = 1.0; 
            if (layers.length > 1) { 
                drawInteractionLayer(L, currentFramePrecomputedData, baseSpacing);
            } else {
                lastRenderedInteractionPoints = []; 
            }
        }

        // --- Edge Configuration Management ---
        function createEdgeConfigHTML(config) {
            const div = document.createElement('div');
            div.className = 'edge-config-item';
            div.id = config.id;

            const headerDiv = document.createElement('div');
            headerDiv.style.overflow = "hidden"; 

            const enableCheckbox = document.createElement('input');
            enableCheckbox.type = 'checkbox';
            enableCheckbox.id = `enable-${config.id}`;
            enableCheckbox.checked = config.enabled;
            
            const enableLabel = document.createElement('label');
            enableLabel.htmlFor = `enable-${config.id}`;
            enableLabel.className = 'label-inline';
            enableLabel.textContent = 'Enable this Edge Type';
            enableLabel.style.marginRight = '10px';

            const removeButton = document.createElement('button');
            removeButton.className = 'remove-button';
            removeButton.dataset.id = config.id;
            removeButton.textContent = 'Remove';
            
            headerDiv.appendChild(enableCheckbox);
            headerDiv.appendChild(enableLabel);
            headerDiv.appendChild(removeButton);
            div.appendChild(headerDiv);

            div.innerHTML += `
                <label for="lower-range-${config.id}" style="margin-top:5px;">Min Distance:</label>
                <div class="input-group">
                    <input type="range" id="lower-range-${config.id}" value="${config.lowerBound}" min="0" max="20" step="0.1">
                    <input type="number" id="lower-num-${config.id}" value="${config.lowerBound}" min="0" max="20" step="0.1">
                </div>
                <label for="upper-range-${config.id}" style="margin-top:5px;">Max Distance:</label>
                <div class="input-group">
                    <input type="range" id="upper-range-${config.id}" value="${config.upperBound}" min="0" max="20" step="0.1">
                    <input type="number" id="upper-num-${config.id}" value="${config.upperBound}" min="0" max="20" step="0.1">
                </div>
                <label for="color-${config.id}">Edge Color:</label>
                <input type="color" id="color-${config.id}" value="${config.color}">
                <label for="width-${config.id}">Edge Width (px):</label>
                <input type="number" id="width-${config.id}" value="${config.width}" min="0.1" max="10" step="0.1" style="width: 70px; margin-bottom: 5px;">
            `;

             div.querySelector(`#enable-${config.id}`).addEventListener('change', (e) => {
                config.enabled = e.target.checked;
                drawSimulation();
            });
             div.querySelector('.remove-button').addEventListener('click', (e) => {
                removeEdgeConfig(e.target.dataset.id);
            });

            const lowerRange = div.querySelector(`#lower-range-${config.id}`);
            const lowerNum = div.querySelector(`#lower-num-${config.id}`);
            const upperRange = div.querySelector(`#upper-range-${config.id}`);
            const upperNum = div.querySelector(`#upper-num-${config.id}`);
            
            const syncBounds = (lowerVal, upperVal) => {
                config.lowerBound = lowerVal;
                config.upperBound = upperVal;
                if(config.lowerBound > config.upperBound) {
                    config.upperBound = config.lowerBound;
                    upperRange.value = config.upperBound.toFixed(1);
                    upperNum.value = config.upperBound.toFixed(1);
                }
                if(config.upperBound < config.lowerBound) {
                    config.lowerBound = config.upperBound;
                    lowerRange.value = config.lowerBound.toFixed(1);
                    lowerNum.value = config.lowerBound.toFixed(1);
                }
                drawSimulation();
            };

            lowerRange.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                lowerNum.value = val.toFixed(1);
                syncBounds(val, config.upperBound);
            });
            lowerNum.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value); if (isNaN(val)) val = 0;
                val = Math.max(0, Math.min(20, val)); e.target.value = val.toFixed(1);
                lowerRange.value = val.toFixed(1);
                syncBounds(val, config.upperBound);
            });
             upperRange.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                upperNum.value = val.toFixed(1);
                syncBounds(config.lowerBound, val);
            });
            upperNum.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value); if (isNaN(val)) val = 0;
                val = Math.max(0, Math.min(20, val)); e.target.value = val.toFixed(1);
                upperRange.value = val.toFixed(1);
                syncBounds(config.lowerBound, val);
            });

            div.querySelector(`#color-${config.id}`).addEventListener('input', (e) => {
                config.color = e.target.value;
                drawSimulation();
            });
            div.querySelector(`#width-${config.id}`).addEventListener('input', (e) => {
                let val = parseFloat(e.target.value); if(isNaN(val)) val = 0.1;
                val = Math.max(0.1, Math.min(10, val)); e.target.value = val.toFixed(1);
                config.width = val;
                drawSimulation();
            });
            return div;
        }

        function addNewEdgeConfig() {
            const newConfig = {
                id: `edgeConfig-${edgeConfigCounter++}`,
                lowerBound: 0, // units
                upperBound: 2, // units
                color: '#'+(Math.random()*0xFFFFFF<<0).toString(16).padStart(6, '0'), 
                width: 1.5,
                enabled: false
            };
            edgeConfigs.push(newConfig);
            const configElement = createEdgeConfigHTML(newConfig);
            controls.interactionEdgeConfigsContainer.appendChild(configElement);
            drawSimulation();
        }

        function removeEdgeConfig(configId) {
            edgeConfigs = edgeConfigs.filter(config => config.id !== configId);
            const elementToRemove = document.getElementById(configId);
            if (elementToRemove) {
                controls.interactionEdgeConfigsContainer.removeChild(elementToRemove);
            }
            drawSimulation();
        }
        
        function initializeEdgeConfigs() {
            controls.interactionEdgeConfigsContainer.innerHTML = ''; 
            if (edgeConfigs.length === 0) {
                 addNewEdgeConfig(); 
            } else {
                 edgeConfigs.forEach(config => {
                    const configElement = createEdgeConfigHTML(config);
                    controls.interactionEdgeConfigsContainer.appendChild(configElement);
                });
            }
        }

        function drawInteractionLayer(L, allPrecomputedData, baseSpacing) {
            if (!controls.enableInteractions.checked) {
                lastRenderedInteractionPoints = []; 
                return;
            }

            const thresholdInUnits = parseFloat(controls.distanceThreshold.value);
            const thresholdPx = thresholdInUnits * baseSpacing;
            const interactionPtSize = parseFloat(controls.interactionPointSize.value);
            const interactingLayersData = allPrecomputedData.filter(ld => ld.contributesToInteraction && ld.transformedPoints && ld.transformedPoints.length > 0);
            
            if (interactingLayersData.length < 2) { 
                 lastRenderedInteractionPoints = [];
                 return;
            }

            const redLayerData = interactingLayersData[0]; 
            const otherLayersData = interactingLayersData.slice(1); 
            const currentFrameInteractionPoints = []; 

            redLayerData.transformedPoints.forEach(rp => {
                let clusterPoints = [rp]; 
                let participatingNeighbors = [];
                let minDistanceToOtherLayer = Infinity;
                otherLayersData.forEach(otherLayer => {
                    let nearestNeighborThisLayer = null;
                    let minDistSqThisLayer = Infinity;
                    otherLayer.transformedPoints.forEach(op => {
                        const distSq = Math.pow(rp.x - op.x, 2) + Math.pow(rp.y - op.y, 2);
                        if (distSq < minDistSqThisLayer) {
                            minDistSqThisLayer = distSq;
                            nearestNeighborThisLayer = op;
                        }
                    });
                    if (nearestNeighborThisLayer) {
                        const actualDist = Math.sqrt(minDistSqThisLayer);
                        if (actualDist <= thresholdPx) { 
                            participatingNeighbors.push(nearestNeighborThisLayer);
                            minDistanceToOtherLayer = Math.min(minDistanceToOtherLayer, actualDist);
                        }
                    }
                });
                if (participatingNeighbors.length > 0) {
                    clusterPoints.push(...participatingNeighbors); 
                    let sumX = 0, sumY = 0;
                    clusterPoints.forEach(p => { sumX += p.x; sumY += p.y; });
                    const avgX = sumX / clusterPoints.length;
                    const avgY = sumY / clusterPoints.length;
                    const color = getColorForDistanceViridisLog(minDistanceToOtherLayer, thresholdPx);
                    currentFrameInteractionPoints.push({x: avgX, y: avgY, color: color, distance: minDistanceToOtherLayer, id: `ip-${currentFrameInteractionPoints.length}`}); 
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(avgX, avgY, interactionPtSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            lastRenderedInteractionPoints = currentFrameInteractionPoints; 

            if (lastRenderedInteractionPoints.length > 1) {
                edgeConfigs.forEach(config => {
                    if (config.enabled) {
                        const lowerBoundPx = config.lowerBound * baseSpacing;
                        const upperBoundPx = config.upperBound * baseSpacing;
                        ctx.strokeStyle = config.color;
                        ctx.lineWidth = config.width;
                        ctx.globalAlpha = 0.7; 
                        for (let i = 0; i < lastRenderedInteractionPoints.length; i++) {
                            for (let j = i + 1; j < lastRenderedInteractionPoints.length; j++) { 
                                const p1 = lastRenderedInteractionPoints[i];
                                const p2 = lastRenderedInteractionPoints[j];
                                const dist = calculateDistance(p1, p2);
                                if (dist >= lowerBoundPx && dist <= upperBoundPx) {
                                    ctx.beginPath();
                                    ctx.moveTo(p1.x, p1.y);
                                    ctx.lineTo(p2.x, p2.y);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                });
                ctx.globalAlpha = 1.0; 
            }
        }

        // --- Export Functionality ---
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportInteractionPoints() {
            if (lastRenderedInteractionPoints.length === 0) {
                alert("No interaction points to export. Ensure 'Enable Interaction Layer' is checked and layers are configured for interaction.");
                return;
            }

            // File 1: Coordinates
            let xyContent = "x_px,y_px\n"; 
            lastRenderedInteractionPoints.forEach(p => {
                xyContent += `${p.x.toFixed(3)},${p.y.toFixed(3)}\n`;
            });
            downloadFile("interaction_points_xy.txt", xyContent);

            // File 2: Distances
            let distanceContent = "distance_to_nearest_primary_px\n";
            lastRenderedInteractionPoints.forEach(p => {
                distanceContent += `${p.distance.toFixed(3)}\n`;
            });
            downloadFile("interaction_points_distances.txt", distanceContent);
        }
        controls.exportInteractionPointsButton.addEventListener('click', exportInteractionPoints);

        // --- Event Listeners for Global Controls ---
        const handleSettingsChange = () => {
            invalidateAllPointCaches(); 
            generateLayerControls(); 
            drawSimulation();
        };

        controls.latticeSize.addEventListener('input', () => {
            handleSettingsChange();
            resizeCanvasContainer(); 
        });
        controls.baseSpacing.addEventListener('input', handleSettingsChange);
        controls.numLayers.addEventListener('change', updateNumberOfLayers);
        controls.pointSize.addEventListener('input', drawSimulation); 
        controls.interactionPointSize.addEventListener('input', drawSimulation);
        
        controls.distanceThreshold.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value).toFixed(2); 
            controls.distanceThresholdLabel.textContent = `Point Distance Threshold: ${val}`;
            controls.distanceThresholdNumber.value = val;
            drawSimulation();
        });
        controls.distanceThresholdNumber.addEventListener('input', (e) => {
            let val = parseFloat(e.target.value);
            if(isNaN(val)) val = parseFloat(controls.distanceThreshold.min); 
            val = Math.max(parseFloat(controls.distanceThreshold.min), Math.min(parseFloat(controls.distanceThreshold.max), val));
            const formattedVal = val.toFixed(2); 
            e.target.value = formattedVal; 
            controls.distanceThresholdLabel.textContent = `Point Distance Threshold: ${formattedVal}`;
            controls.distanceThreshold.value = formattedVal; 
            drawSimulation();
        });
        controls.enableInteractions.addEventListener('change', drawSimulation);
        controls.addEdgeConfigButton.addEventListener('click', addNewEdgeConfig);


        function resizeCanvasContainer() {
            const controlPanelWidth = document.getElementById('controls').offsetWidth;
            const padding = 40; 
            const availableWidth = window.innerWidth - controlPanelWidth - padding; 
            const availableHeight = window.innerHeight - padding; 
            const L = parseInt(controls.latticeSize.value); 
            let displayScale = 1;
            if (L > 0) { 
                if (L > availableWidth || L > availableHeight) {
                    displayScale = Math.min(availableWidth / L, availableHeight / L);
                }
                displayScale = Math.max(0.1, displayScale); 
            } else { 
                displayScale = 1; 
            }
            canvas.style.width = (L * displayScale) + 'px';
            canvas.style.height = (L * displayScale) + 'px';
        }

        // --- Initial Setup ---
        window.addEventListener('resize', () => { 
            resizeCanvasContainer(); 
        });
        
        updateNumberOfLayers(); 
        initializeEdgeConfigs(); 
        resizeCanvasContainer(); 
        
    </script></body>
</html>
